{"version":3,"file":"slate.es.js","sources":["../src/models/data.js","../src/constants/model-types.js","../../../node_modules/rollup-plugin-node-globals/src/global.js","../../../node_modules/process-es6/browser.js","../src/utils/memoize.js","../src/models/mark.js","../src/models/range.js","../src/models/character.js","../src/models/leaf.js","../src/utils/generate-key.js","../src/models/text.js","../src/utils/is-index-in-range.js","../src/models/node.js","../src/models/inline.js","../src/models/document.js","../src/models/block.js","../src/changes/at-current-range.js","../src/utils/string.js","../src/changes/at-range.js","../src/changes/by-key.js","../src/constants/operation-attributes.js","../src/models/history.js","../src/constants/core-schema-rules.js","../src/models/stack.js","../src/models/schema.js","../src/models/value.js","../src/models/operation.js","../src/operations/invert.js","../src/changes/on-history.js","../src/changes/on-selection.js","../src/changes/on-value.js","../src/changes/with-schema.js","../src/changes/index.js","../src/operations/apply.js","../src/models/change.js","../src/operations/index.js","../src/index.js"],"sourcesContent":["import isPlainObject from 'is-plain-object'\nimport { Map } from 'immutable'\n\n/**\n * Data.\n *\n * This isn't an immutable record, it's just a thin wrapper around `Map` so that\n * we can allow for more convenient creation.\n *\n * @type {Object}\n */\n\nclass Data {\n  /**\n   * Create a new `Data` with `attrs`.\n   *\n   * @param {Object|Data|Map} attrs\n   * @return {Data} data\n   */\n\n  static create(attrs = {}) {\n    if (Map.isMap(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Data.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Data.create\\` only accepts objects or maps, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Data` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Data}\n   */\n\n  static fromJSON(object) {\n    return new Map(object)\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Data.fromJSON\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Data\n","/**\n * Slate-specific model types.\n *\n * @type {Object}\n */\n\nconst MODEL_TYPES = {\n  BLOCK: '@@__SLATE_BLOCK__@@',\n  CHANGE: '@@__SLATE_CHANGE__@@',\n  CHARACTER: '@@__SLATE_CHARACTER__@@',\n  DOCUMENT: '@@__SLATE_DOCUMENT__@@',\n  HISTORY: '@@__SLATE_HISTORY__@@',\n  INLINE: '@@__SLATE_INLINE__@@',\n  LEAF: '@@__SLATE_LEAF__@@',\n  MARK: '@@__SLATE_MARK__@@',\n  OPERATION: '@@__SLATE_OPERATION__@@',\n  RANGE: '@@__SLATE_RANGE__@@',\n  SCHEMA: '@@__SLATE_SCHEMA__@@',\n  STACK: '@@__SLATE_STACK__@@',\n  TEXT: '@@__SLATE_TEXT__@@',\n  VALUE: '@@__SLATE_VALUE__@@',\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default MODEL_TYPES\n","export default typeof global !== \"undefined\" ? global :\n            typeof self !== \"undefined\" ? self :\n            typeof window !== \"undefined\" ? window : {}\n","// shim for using process in browser\n// based off https://github.com/defunctzombie/node-process/blob/master/browser.js\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\nvar cachedSetTimeout = defaultSetTimout;\nvar cachedClearTimeout = defaultClearTimeout;\nif (typeof global.setTimeout === 'function') {\n    cachedSetTimeout = setTimeout;\n}\nif (typeof global.clearTimeout === 'function') {\n    cachedClearTimeout = clearTimeout;\n}\n\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\nexport function nextTick(fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n}\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nexport var title = 'browser';\nexport var platform = 'browser';\nexport var browser = true;\nexport var env = {};\nexport var argv = [];\nexport var version = ''; // empty string to avoid regexp issues\nexport var versions = {};\nexport var release = {};\nexport var config = {};\n\nfunction noop() {}\n\nexport var on = noop;\nexport var addListener = noop;\nexport var once = noop;\nexport var off = noop;\nexport var removeListener = noop;\nexport var removeAllListeners = noop;\nexport var emit = noop;\n\nexport function binding(name) {\n    throw new Error('process.binding is not supported');\n}\n\nexport function cwd () { return '/' }\nexport function chdir (dir) {\n    throw new Error('process.chdir is not supported');\n};\nexport function umask() { return 0; }\n\n// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js\nvar performance = global.performance || {}\nvar performanceNow =\n  performance.now        ||\n  performance.mozNow     ||\n  performance.msNow      ||\n  performance.oNow       ||\n  performance.webkitNow  ||\n  function(){ return (new Date()).getTime() }\n\n// generate timestamp or delta\n// see http://nodejs.org/api/process.html#process_process_hrtime\nexport function hrtime(previousTimestamp){\n  var clocktime = performanceNow.call(performance)*1e-3\n  var seconds = Math.floor(clocktime)\n  var nanoseconds = Math.floor((clocktime%1)*1e9)\n  if (previousTimestamp) {\n    seconds = seconds - previousTimestamp[0]\n    nanoseconds = nanoseconds - previousTimestamp[1]\n    if (nanoseconds<0) {\n      seconds--\n      nanoseconds += 1e9\n    }\n  }\n  return [seconds,nanoseconds]\n}\n\nvar startTime = new Date();\nexport function uptime() {\n  var currentTime = new Date();\n  var dif = currentTime - startTime;\n  return dif / 1000;\n}\n\nexport default {\n  nextTick: nextTick,\n  title: title,\n  browser: browser,\n  env: env,\n  argv: argv,\n  version: version,\n  versions: versions,\n  on: on,\n  addListener: addListener,\n  once: once,\n  off: off,\n  removeListener: removeListener,\n  removeAllListeners: removeAllListeners,\n  emit: emit,\n  binding: binding,\n  cwd: cwd,\n  chdir: chdir,\n  umask: umask,\n  hrtime: hrtime,\n  platform: platform,\n  release: release,\n  config: config,\n  uptime: uptime\n};\n","/**\n * Is in development?\n *\n * @type {Boolean}\n */\n\nconst IS_DEV =\n  typeof process !== 'undefined' &&\n  process.env &&\n  process.env.NODE_ENV !== 'production'\n\n/**\n * GLOBAL: True if memoization should is enabled. Only effective when `IS_DEV`.\n *\n * @type {Boolean}\n */\n\nlet ENABLED = true\n\n/**\n * GLOBAL: Changing this cache key will clear all previous cached results.\n * Only effective when `IS_DEV`.\n *\n * @type {Number}\n */\n\nlet CACHE_KEY = 0\n\n/**\n * The leaf node of a cache tree. Used to support variable argument length. A\n * unique object, so that native Maps will key it by reference.\n *\n * @type {Object}\n */\n\nconst LEAF = {}\n\n/**\n * A value to represent a memoized undefined value. Allows efficient value\n * retrieval using Map.get only.\n *\n * @type {Object}\n */\n\nconst UNDEFINED = {}\n\n/**\n * Default value for unset keys in native Maps\n *\n * @type {Undefined}\n */\n\nconst UNSET = undefined\n\n/**\n * Memoize all of the `properties` on a `object`.\n *\n * @param {Object} object\n * @param {Array} properties\n * @return {Record}\n */\n\nfunction memoize(object, properties, options = {}) {\n  const { takesArguments = true } = options\n\n  for (const property of properties) {\n    const original = object[property]\n\n    if (!original) {\n      throw new Error(`Object does not have a property named \"${property}\".`)\n    }\n\n    object[property] = function(...args) {\n      if (IS_DEV) {\n        // If memoization is disabled, call into the original method.\n        if (!ENABLED) return original.apply(this, args)\n\n        // If the cache key is different, previous caches must be cleared.\n        if (CACHE_KEY !== this.__cache_key) {\n          this.__cache_key = CACHE_KEY\n          this.__cache = new Map() // eslint-disable-line no-undef,no-restricted-globals\n        }\n      }\n\n      if (!this.__cache) {\n        this.__cache = new Map() // eslint-disable-line no-undef,no-restricted-globals\n      }\n\n      let cachedValue\n      let keys\n\n      if (takesArguments) {\n        keys = [property, ...args]\n        cachedValue = getIn(this.__cache, keys)\n      } else {\n        cachedValue = this.__cache.get(property)\n      }\n\n      // If we've got a result already, return it.\n      if (cachedValue !== UNSET) {\n        return cachedValue === UNDEFINED ? undefined : cachedValue\n      }\n\n      // Otherwise calculate what it should be once and cache it.\n      const value = original.apply(this, args)\n      const v = value === undefined ? UNDEFINED : value\n\n      if (takesArguments) {\n        this.__cache = setIn(this.__cache, keys, v)\n      } else {\n        this.__cache.set(property, v)\n      }\n\n      return value\n    }\n  }\n}\n\n/**\n * Get a value at a key path in a tree of Map.\n *\n * If not set, returns UNSET.\n * If the set value is undefined, returns UNDEFINED.\n *\n * @param {Map} map\n * @param {Array} keys\n * @return {Any|UNSET|UNDEFINED}\n */\n\nfunction getIn(map, keys) {\n  for (const key of keys) {\n    map = map.get(key)\n    if (map === UNSET) return UNSET\n  }\n\n  return map.get(LEAF)\n}\n\n/**\n * Set a value at a key path in a tree of Map, creating Maps on the go.\n *\n * @param {Map} map\n * @param {Array} keys\n * @param {Any} value\n * @return {Map}\n */\n\nfunction setIn(map, keys, value) {\n  let parent = map\n  let child\n\n  for (const key of keys) {\n    child = parent.get(key)\n\n    // If the path was not created yet...\n    if (child === UNSET) {\n      child = new Map() // eslint-disable-line no-undef,no-restricted-globals\n      parent.set(key, child)\n    }\n\n    parent = child\n  }\n\n  // The whole path has been created, so set the value to the bottom most map.\n  child.set(LEAF, value)\n  return map\n}\n\n/**\n * In DEV mode, clears the previously memoized values, globally.\n *\n * @return {Void}\n */\n\nfunction resetMemoization() {\n  CACHE_KEY++\n\n  if (CACHE_KEY >= Number.MAX_SAFE_INTEGER) {\n    CACHE_KEY = 0\n  }\n}\n\n/**\n * In DEV mode, enable or disable the use of memoize values, globally.\n *\n * @param {Boolean} enabled\n * @return {Void}\n */\n\nfunction useMemoization(enabled) {\n  ENABLED = enabled\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default memoize\nexport { resetMemoization, useMemoization }\n","import isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { Map, Record, Set } from 'immutable'\n\nimport MODEL_TYPES from '../constants/model-types'\nimport Data from './data'\nimport memoize from '../utils/memoize'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: new Map(),\n  type: undefined,\n}\n\n/**\n * Mark.\n *\n * @type {Mark}\n */\n\nclass Mark extends Record(DEFAULTS) {\n  /**\n   * Create a new `Mark` with `attrs`.\n   *\n   * @param {Object|Mark} attrs\n   * @return {Mark}\n   */\n\n  static create(attrs = {}) {\n    if (Mark.isMark(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs == 'string') {\n      attrs = { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Mark.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Mark.create\\` only accepts objects, strings or marks, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a set of marks.\n   *\n   * @param {Array<Object|Mark>} elements\n   * @return {Set<Mark>}\n   */\n\n  static createSet(elements) {\n    if (Set.isSet(elements) || Array.isArray(elements)) {\n      const marks = new Set(elements.map(Mark.create))\n      return marks\n    }\n\n    if (elements == null) {\n      return new Set()\n    }\n\n    throw new Error(\n      `\\`Mark.createSet\\` only accepts sets, arrays or null, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable mark properties from `attrs`.\n   *\n   * @param {Object|String|Mark} attrs\n   * @return {Object}\n   */\n\n  static createProperties(attrs = {}) {\n    if (Mark.isMark(attrs)) {\n      return {\n        data: attrs.data,\n        type: attrs.type,\n      }\n    }\n\n    if (typeof attrs == 'string') {\n      return { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      const props = {}\n      if ('type' in attrs) props.type = attrs.type\n      if ('data' in attrs) props.data = Data.create(attrs.data)\n      return props\n    }\n\n    throw new Error(\n      `\\`Mark.createProperties\\` only accepts objects, strings or marks, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Mark` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Mark}\n   */\n\n  static fromJSON(object) {\n    const { data = {}, type } = object\n\n    if (typeof type != 'string') {\n      throw new Error('`Mark.fromJS` requires a `type` string.')\n    }\n\n    const mark = new Mark({\n      type,\n      data: new Map(data),\n    })\n\n    return mark\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Mark.fromJSON\n\n  /**\n   * Check if `any` is a `Mark`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isMark(any) {\n    return !!(any && any[MODEL_TYPES.MARK])\n  }\n\n  /**\n   * Check if `any` is a set of marks.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isMarkSet(any) {\n    return Set.isSet(any) && any.every(item => Mark.isMark(item))\n  }\n\n  /**\n   * Object.\n   */\n\n  get object() {\n    return 'mark'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Get the component for the node from a `schema`.\n   *\n   * @param {Schema} schema\n   * @return {Component|Void}\n   */\n\n  getComponent(schema) {\n    return schema.__getComponent(this)\n  }\n\n  /**\n   * Return a JSON representation of the mark.\n   *\n   * @return {Object}\n   */\n\n  toJSON() {\n    const object = {\n      object: this.object,\n      type: this.type,\n      data: this.data.toJSON(),\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS() {\n    return this.toJSON()\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nMark.prototype[MODEL_TYPES.MARK] = true\n\n/**\n * Memoize read methods.\n */\n\nmemoize(Mark.prototype, ['getComponent'], {\n  takesArguments: true,\n})\n\n/**\n * Export.\n *\n * @type {Mark}\n */\n\nexport default Mark\n","import isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { List, Record, Set } from 'immutable'\n\nimport MODEL_TYPES from '../constants/model-types'\nimport Mark from './mark'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  anchorKey: null,\n  anchorOffset: 0,\n  focusKey: null,\n  focusOffset: 0,\n  isBackward: null,\n  isFocused: false,\n  marks: null,\n}\n\n/**\n * Range.\n *\n * @type {Range}\n */\n\nclass Range extends Record(DEFAULTS) {\n  /**\n   * Create a new `Range` with `attrs`.\n   *\n   * @param {Object|Range} attrs\n   * @return {Range}\n   */\n\n  static create(attrs = {}) {\n    if (Range.isRange(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Range.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Range.create\\` only accepts objects or ranges, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Ranges` from `elements`.\n   *\n   * @param {Array<Range|Object>|List<Range|Object>} elements\n   * @return {List<Range>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Range.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Range.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable range properties from `attrs`.\n   *\n   * @param {Object|String|Range} attrs\n   * @return {Object}\n   */\n\n  static createProperties(attrs = {}) {\n    if (Range.isRange(attrs)) {\n      return {\n        anchorKey: attrs.anchorKey,\n        anchorOffset: attrs.anchorOffset,\n        focusKey: attrs.focusKey,\n        focusOffset: attrs.focusOffset,\n        isBackward: attrs.isBackward,\n        isFocused: attrs.isFocused,\n        marks: attrs.marks,\n      }\n    }\n\n    if (isPlainObject(attrs)) {\n      const props = {}\n      if ('anchorKey' in attrs) props.anchorKey = attrs.anchorKey\n      if ('anchorOffset' in attrs) props.anchorOffset = attrs.anchorOffset\n      if ('anchorPath' in attrs) props.anchorPath = attrs.anchorPath\n      if ('focusKey' in attrs) props.focusKey = attrs.focusKey\n      if ('focusOffset' in attrs) props.focusOffset = attrs.focusOffset\n      if ('focusPath' in attrs) props.focusPath = attrs.focusPath\n      if ('isBackward' in attrs) props.isBackward = attrs.isBackward\n      if ('isFocused' in attrs) props.isFocused = attrs.isFocused\n      if ('marks' in attrs)\n        props.marks = attrs.marks == null ? null : Mark.createSet(attrs.marks)\n      return props\n    }\n\n    throw new Error(\n      `\\`Range.createProperties\\` only accepts objects or ranges, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Range` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Range}\n   */\n\n  static fromJSON(object) {\n    const {\n      anchorKey = null,\n      anchorOffset = 0,\n      focusKey = null,\n      focusOffset = 0,\n      isBackward = null,\n      isFocused = false,\n      marks = null,\n    } = object\n\n    const range = new Range({\n      anchorKey,\n      anchorOffset,\n      focusKey,\n      focusOffset,\n      isBackward,\n      isFocused,\n      marks: marks == null ? null : new Set(marks.map(Mark.fromJSON)),\n    })\n\n    return range\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Range.fromJSON\n\n  /**\n   * Check if an `obj` is a `Range`.\n   *\n   * @param {Any} obj\n   * @return {Boolean}\n   */\n\n  static isRange(obj) {\n    return !!(obj && obj[MODEL_TYPES.RANGE])\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'range'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Check whether the range is blurred.\n   *\n   * @return {Boolean}\n   */\n\n  get isBlurred() {\n    return !this.isFocused\n  }\n\n  /**\n   * Check whether the range is collapsed.\n   *\n   * @return {Boolean}\n   */\n\n  get isCollapsed() {\n    return (\n      this.anchorKey == this.focusKey && this.anchorOffset == this.focusOffset\n    )\n  }\n\n  /**\n   * Check whether the range is expanded.\n   *\n   * @return {Boolean}\n   */\n\n  get isExpanded() {\n    return !this.isCollapsed\n  }\n\n  /**\n   * Check whether the range is forward.\n   *\n   * @return {Boolean}\n   */\n\n  get isForward() {\n    return this.isBackward == null ? null : !this.isBackward\n  }\n\n  /**\n   * Check whether the range's keys are set.\n   *\n   * @return {Boolean}\n   */\n\n  get isSet() {\n    return this.anchorKey != null && this.focusKey != null\n  }\n\n  /**\n   * Check whether the range's keys are not set.\n   *\n   * @return {Boolean}\n   */\n\n  get isUnset() {\n    return !this.isSet\n  }\n\n  /**\n   * Get the start key.\n   *\n   * @return {String}\n   */\n\n  get startKey() {\n    return this.isBackward ? this.focusKey : this.anchorKey\n  }\n\n  /**\n   * Get the start offset.\n   *\n   * @return {String}\n   */\n\n  get startOffset() {\n    return this.isBackward ? this.focusOffset : this.anchorOffset\n  }\n\n  /**\n   * Get the end key.\n   *\n   * @return {String}\n   */\n\n  get endKey() {\n    return this.isBackward ? this.anchorKey : this.focusKey\n  }\n\n  /**\n   * Get the end offset.\n   *\n   * @return {String}\n   */\n\n  get endOffset() {\n    return this.isBackward ? this.anchorOffset : this.focusOffset\n  }\n\n  /**\n   * Check whether anchor point of the range is at the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  hasAnchorAtStartOf(node) {\n    // PERF: Do a check for a `0` offset first since it's quickest.\n    if (this.anchorOffset != 0) return false\n    const first = getFirst(node)\n    return this.anchorKey == first.key\n  }\n\n  /**\n   * Check whether anchor point of the range is at the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  hasAnchorAtEndOf(node) {\n    const last = getLast(node)\n    return this.anchorKey == last.key && this.anchorOffset == last.text.length\n  }\n\n  /**\n   * Check whether the anchor edge of a range is in a `node` and at an\n   * offset between `start` and `end`.\n   *\n   * @param {Node} node\n   * @param {Number} start\n   * @param {Number} end\n   * @return {Boolean}\n   */\n\n  hasAnchorBetween(node, start, end) {\n    return (\n      this.anchorOffset <= end &&\n      start <= this.anchorOffset &&\n      this.hasAnchorIn(node)\n    )\n  }\n\n  /**\n   * Check whether the anchor edge of a range is in a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  hasAnchorIn(node) {\n    return node.object == 'text'\n      ? node.key == this.anchorKey\n      : this.anchorKey != null && node.hasDescendant(this.anchorKey)\n  }\n\n  /**\n   * Check whether focus point of the range is at the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  hasFocusAtEndOf(node) {\n    const last = getLast(node)\n    return this.focusKey == last.key && this.focusOffset == last.text.length\n  }\n\n  /**\n   * Check whether focus point of the range is at the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  hasFocusAtStartOf(node) {\n    if (this.focusOffset != 0) return false\n    const first = getFirst(node)\n    return this.focusKey == first.key\n  }\n\n  /**\n   * Check whether the focus edge of a range is in a `node` and at an\n   * offset between `start` and `end`.\n   *\n   * @param {Node} node\n   * @param {Number} start\n   * @param {Number} end\n   * @return {Boolean}\n   */\n\n  hasFocusBetween(node, start, end) {\n    return (\n      start <= this.focusOffset &&\n      this.focusOffset <= end &&\n      this.hasFocusIn(node)\n    )\n  }\n\n  /**\n   * Check whether the focus edge of a range is in a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  hasFocusIn(node) {\n    return node.object == 'text'\n      ? node.key == this.focusKey\n      : this.focusKey != null && node.hasDescendant(this.focusKey)\n  }\n\n  /**\n   * Check whether the range is at the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  isAtStartOf(node) {\n    return this.isCollapsed && this.hasAnchorAtStartOf(node)\n  }\n\n  /**\n   * Check whether the range is at the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  isAtEndOf(node) {\n    return this.isCollapsed && this.hasAnchorAtEndOf(node)\n  }\n\n  /**\n   * Focus the range.\n   *\n   * @return {Range}\n   */\n\n  focus() {\n    return this.merge({\n      isFocused: true,\n    })\n  }\n\n  /**\n   * Blur the range.\n   *\n   * @return {Range}\n   */\n\n  blur() {\n    return this.merge({\n      isFocused: false,\n    })\n  }\n\n  /**\n   * Unset the range.\n   *\n   * @return {Range}\n   */\n\n  deselect() {\n    return this.merge({\n      anchorKey: null,\n      anchorOffset: 0,\n      focusKey: null,\n      focusOffset: 0,\n      isFocused: false,\n      isBackward: false,\n    })\n  }\n\n  /**\n   * Flip the range.\n   *\n   * @return {Range}\n   */\n\n  flip() {\n    return this.merge({\n      anchorKey: this.focusKey,\n      anchorOffset: this.focusOffset,\n      focusKey: this.anchorKey,\n      focusOffset: this.anchorOffset,\n      isBackward: this.isBackward == null ? null : !this.isBackward,\n    })\n  }\n\n  /**\n   * Move the anchor offset `n` characters.\n   *\n   * @param {Number} n (optional)\n   * @return {Range}\n   */\n\n  moveAnchor(n = 1) {\n    const { anchorKey, focusKey, focusOffset, isBackward } = this\n    const anchorOffset = this.anchorOffset + n\n    return this.merge({\n      anchorOffset,\n      isBackward:\n        anchorKey == focusKey ? anchorOffset > focusOffset : isBackward,\n    })\n  }\n\n  /**\n   * Move the anchor offset `n` characters.\n   *\n   * @param {Number} n (optional)\n   * @return {Range}\n   */\n\n  moveFocus(n = 1) {\n    const { anchorKey, anchorOffset, focusKey, isBackward } = this\n    const focusOffset = this.focusOffset + n\n    return this.merge({\n      focusOffset,\n      isBackward:\n        focusKey == anchorKey ? anchorOffset > focusOffset : isBackward,\n    })\n  }\n\n  /**\n   * Move the range's anchor point to a `key` and `offset`.\n   *\n   * @param {String} key\n   * @param {Number} offset\n   * @return {Range}\n   */\n\n  moveAnchorTo(key, offset) {\n    const { anchorKey, focusKey, focusOffset, isBackward } = this\n    return this.merge({\n      anchorKey: key,\n      anchorOffset: offset,\n      isBackward:\n        key == focusKey\n          ? offset > focusOffset\n          : key == anchorKey ? isBackward : null,\n    })\n  }\n\n  /**\n   * Move the range's focus point to a `key` and `offset`.\n   *\n   * @param {String} key\n   * @param {Number} offset\n   * @return {Range}\n   */\n\n  moveFocusTo(key, offset) {\n    const { focusKey, anchorKey, anchorOffset, isBackward } = this\n    return this.merge({\n      focusKey: key,\n      focusOffset: offset,\n      isBackward:\n        key == anchorKey\n          ? anchorOffset > offset\n          : key == focusKey ? isBackward : null,\n    })\n  }\n\n  /**\n   * Move the range to `anchorOffset`.\n   *\n   * @param {Number} anchorOffset\n   * @return {Range}\n   */\n\n  moveAnchorOffsetTo(anchorOffset) {\n    return this.merge({\n      anchorOffset,\n      isBackward:\n        this.anchorKey == this.focusKey\n          ? anchorOffset > this.focusOffset\n          : this.isBackward,\n    })\n  }\n\n  /**\n   * Move the range to `focusOffset`.\n   *\n   * @param {Number} focusOffset\n   * @return {Range}\n   */\n\n  moveFocusOffsetTo(focusOffset) {\n    return this.merge({\n      focusOffset,\n      isBackward:\n        this.anchorKey == this.focusKey\n          ? this.anchorOffset > focusOffset\n          : this.isBackward,\n    })\n  }\n\n  /**\n   * Move the range to `anchorOffset` and `focusOffset`.\n   *\n   * @param {Number} anchorOffset\n   * @param {Number} focusOffset (optional)\n   * @return {Range}\n   */\n\n  moveOffsetsTo(anchorOffset, focusOffset = anchorOffset) {\n    return this.moveAnchorOffsetTo(anchorOffset).moveFocusOffsetTo(focusOffset)\n  }\n\n  /**\n   * Move the focus point to the anchor point.\n   *\n   * @return {Range}\n   */\n\n  moveToAnchor() {\n    return this.moveFocusTo(this.anchorKey, this.anchorOffset)\n  }\n\n  /**\n   * Move the anchor point to the focus point.\n   *\n   * @return {Range}\n   */\n\n  moveToFocus() {\n    return this.moveAnchorTo(this.focusKey, this.focusOffset)\n  }\n\n  /**\n   * Move the range's anchor point to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveAnchorToStartOf(node) {\n    node = getFirst(node)\n    return this.moveAnchorTo(node.key, 0)\n  }\n\n  /**\n   * Move the range's anchor point to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveAnchorToEndOf(node) {\n    node = getLast(node)\n    return this.moveAnchorTo(node.key, node.text.length)\n  }\n\n  /**\n   * Move the range's focus point to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveFocusToStartOf(node) {\n    node = getFirst(node)\n    return this.moveFocusTo(node.key, 0)\n  }\n\n  /**\n   * Move the range's focus point to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveFocusToEndOf(node) {\n    node = getLast(node)\n    return this.moveFocusTo(node.key, node.text.length)\n  }\n\n  /**\n   * Move to the entire range of `start` and `end` nodes.\n   *\n   * @param {Node} start\n   * @param {Node} end (optional)\n   * @return {Range}\n   */\n\n  moveToRangeOf(start, end = start) {\n    const range = this.isBackward ? this.flip() : this\n    return range.moveAnchorToStartOf(start).moveFocusToEndOf(end)\n  }\n\n  /**\n   * Normalize the range, relative to a `node`, ensuring that the anchor\n   * and focus nodes of the range always refer to leaf text nodes.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  normalize(node) {\n    const range = this\n    let { anchorKey, anchorOffset, focusKey, focusOffset, isBackward } = range\n\n    const anchorOffsetType = typeof anchorOffset\n    const focusOffsetType = typeof focusOffset\n    if (anchorOffsetType != 'number' || focusOffsetType != 'number') {\n      logger.warn(\n        `The range offsets should be numbers, but they were of type \"${anchorOffsetType}\" and \"${focusOffsetType}\".`\n      )\n    }\n\n    // If the range is unset, make sure it is properly zeroed out.\n    if (anchorKey == null || focusKey == null) {\n      return range.merge({\n        anchorKey: null,\n        anchorOffset: 0,\n        focusKey: null,\n        focusOffset: 0,\n        isBackward: false,\n      })\n    }\n\n    // Get the anchor and focus nodes.\n    let anchorNode = node.getDescendant(anchorKey)\n    let focusNode = node.getDescendant(focusKey)\n\n    // If the range is malformed, warn and zero it out.\n    if (!anchorNode || !focusNode) {\n      logger.warn(\n        'The range was invalid and was reset. The range in question was:',\n        range\n      )\n      const first = node.getFirstText()\n      return range.merge({\n        anchorKey: first ? first.key : null,\n        anchorOffset: 0,\n        focusKey: first ? first.key : null,\n        focusOffset: 0,\n        isBackward: false,\n      })\n    }\n\n    // If the anchor node isn't a text node, match it to one.\n    if (anchorNode.object != 'text') {\n      logger.warn(\n        'The range anchor was set to a Node that is not a Text node. This should not happen and can degrade performance. The node in question was:',\n        anchorNode\n      )\n      const anchorText = anchorNode.getTextAtOffset(anchorOffset)\n      const offset = anchorNode.getOffset(anchorText.key)\n      anchorOffset = anchorOffset - offset\n      anchorNode = anchorText\n    }\n\n    // If the focus node isn't a text node, match it to one.\n    if (focusNode.object != 'text') {\n      logger.warn(\n        'The range focus was set to a Node that is not a Text node. This should not happen and can degrade performance. The node in question was:',\n        focusNode\n      )\n      const focusText = focusNode.getTextAtOffset(focusOffset)\n      const offset = focusNode.getOffset(focusText.key)\n      focusOffset = focusOffset - offset\n      focusNode = focusText\n    }\n\n    // If `isBackward` is not set, derive it.\n    if (isBackward == null) {\n      if (anchorNode.key === focusNode.key) {\n        isBackward = anchorOffset > focusOffset\n      } else {\n        isBackward = !node.areDescendantsSorted(anchorNode.key, focusNode.key)\n      }\n    }\n\n    // Merge in any updated properties.\n    return range.merge({\n      anchorKey: anchorNode.key,\n      anchorOffset,\n      focusKey: focusNode.key,\n      focusOffset,\n      isBackward,\n    })\n  }\n\n  /**\n   * Return a JSON representation of the range.\n   *\n   * @return {Object}\n   */\n\n  toJSON() {\n    const object = {\n      object: this.object,\n      anchorKey: this.anchorKey,\n      anchorOffset: this.anchorOffset,\n      focusKey: this.focusKey,\n      focusOffset: this.focusOffset,\n      isBackward: this.isBackward,\n      isFocused: this.isFocused,\n      marks:\n        this.marks == null ? null : this.marks.toArray().map(m => m.toJSON()),\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS() {\n    return this.toJSON()\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nRange.prototype[MODEL_TYPES.RANGE] = true\n\n/**\n * Mix in some \"move\" convenience methods.\n */\n\nconst MOVE_METHODS = [\n  ['move', ''],\n  ['move', 'To'],\n  ['move', 'ToStartOf'],\n  ['move', 'ToEndOf'],\n]\n\nMOVE_METHODS.forEach(([p, s]) => {\n  Range.prototype[`${p}${s}`] = function(...args) {\n    return this[`${p}Anchor${s}`](...args)[`${p}Focus${s}`](...args)\n  }\n})\n\n/**\n * Mix in the \"start\", \"end\" and \"edge\" convenience methods.\n */\n\nconst EDGE_METHODS = [\n  ['has', 'AtStartOf', true],\n  ['has', 'AtEndOf', true],\n  ['has', 'Between', true],\n  ['has', 'In', true],\n  ['collapseTo', ''],\n  ['move', ''],\n  ['moveTo', ''],\n  ['move', 'To'],\n  ['move', 'OffsetTo'],\n]\n\nEDGE_METHODS.forEach(([p, s, hasEdge]) => {\n  const anchor = `${p}Anchor${s}`\n  const focus = `${p}Focus${s}`\n\n  Range.prototype[`${p}Start${s}`] = function(...args) {\n    return this.isBackward ? this[focus](...args) : this[anchor](...args)\n  }\n\n  Range.prototype[`${p}End${s}`] = function(...args) {\n    return this.isBackward ? this[anchor](...args) : this[focus](...args)\n  }\n\n  if (hasEdge) {\n    Range.prototype[`${p}Edge${s}`] = function(...args) {\n      return this[anchor](...args) || this[focus](...args)\n    }\n  }\n})\n\n/**\n * Mix in some aliases for convenience / parallelism with the browser APIs.\n */\n\nconst ALIAS_METHODS = [\n  ['collapseTo', 'moveTo'],\n  ['collapseToAnchor', 'moveToAnchor'],\n  ['collapseToFocus', 'moveToFocus'],\n  ['collapseToStart', 'moveToStart'],\n  ['collapseToEnd', 'moveToEnd'],\n  ['collapseToStartOf', 'moveToStartOf'],\n  ['collapseToEndOf', 'moveToEndOf'],\n  ['extend', 'moveFocus'],\n  ['extendTo', 'moveFocusTo'],\n  ['extendToStartOf', 'moveFocusToStartOf'],\n  ['extendToEndOf', 'moveFocusToEndOf'],\n]\n\nALIAS_METHODS.forEach(([alias, method]) => {\n  Range.prototype[alias] = function(...args) {\n    return this[method](...args)\n  }\n})\n\n/**\n * Get the first text of a `node`.\n *\n * @param {Node} node\n * @return {Text}\n */\n\nfunction getFirst(node) {\n  return node.object == 'text' ? node : node.getFirstText()\n}\n\n/**\n * Get the last text of a `node`.\n *\n * @param {Node} node\n * @return {Text}\n */\n\nfunction getLast(node) {\n  return node.object == 'text' ? node : node.getLastText()\n}\n\n/**\n * Export.\n *\n * @type {Range}\n */\n\nexport default Range\n","import isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { List, Record, Set } from 'immutable'\n\nimport MODEL_TYPES from '../constants/model-types'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  marks: new Set(),\n  text: '',\n}\n\n/**\n * Character.\n *\n * @type {Character}\n */\n\nclass Character extends Record(DEFAULTS) {\n  /**\n   * Create a `Character` with `attrs`.\n   *\n   * @param {Object|String|Character} attrs\n   * @return {Character}\n   */\n\n  static create(attrs = {}) {\n    if (Character.isCharacter(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs == 'string') {\n      attrs = { text: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Character.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Character.create\\` only accepts objects, strings or characters, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Characters` from `elements`.\n   *\n   * @param {String|Array<Object|Character|String>|List<Object|Character|String>} elements\n   * @return {List<Character>}\n   */\n\n  static createList(elements = []) {\n    if (typeof elements == 'string') {\n      elements = elements.split('')\n    }\n\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Character.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Block.createList\\` only accepts strings, arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a `Character` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Character}\n   */\n\n  static fromJSON(object) {\n    const { text, marks = [] } = object\n\n    if (typeof text != 'string') {\n      throw new Error('`Character.fromJSON` requires a block `text` string.')\n    }\n\n    const character = new Character({\n      text,\n      marks: new Set(marks),\n    })\n\n    return character\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Character.fromJSON\n\n  /**\n   * Check if `any` is a `Character`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isCharacter(any) {\n    return !!(any && any[MODEL_TYPES.CHARACTER])\n  }\n\n  /**\n   * Check if `any` is a character list.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isCharacterList(any) {\n    return List.isList(any) && any.every(item => Character.isCharacter(item))\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'character'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Return a JSON representation of the character.\n   *\n   * @return {Object}\n   */\n\n  toJSON() {\n    const object = {\n      object: this.object,\n      text: this.text,\n      marks: this.marks.toArray().map(m => m.toJSON()),\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS() {\n    return this.toJSON()\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nCharacter.prototype[MODEL_TYPES.CHARACTER] = true\n\n/**\n * Export.\n *\n * @type {Character}\n */\n\nexport default Character\n","import isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { List, Record, Set } from 'immutable'\n\nimport MODEL_TYPES from '../constants/model-types'\nimport Character from './character'\nimport Mark from './mark'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  marks: new Set(),\n  text: '',\n}\n\n/**\n * Leaf.\n *\n * @type {Leaf}\n */\n\nclass Leaf extends Record(DEFAULTS) {\n  /**\n   * Create a new `Leaf` with `attrs`.\n   *\n   * @param {Object|Leaf} attrs\n   * @return {Leaf}\n   */\n\n  static create(attrs = {}) {\n    if (Leaf.isLeaf(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs == 'string') {\n      attrs = { text: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Leaf.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Leaf.create\\` only accepts objects, strings or leaves, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Leaf` list from `attrs`.\n   *\n   * @param {Array<Leaf|Object>|List<Leaf|Object>} attrs\n   * @return {List<Leaf>}\n   */\n\n  static createList(attrs = []) {\n    if (List.isList(attrs) || Array.isArray(attrs)) {\n      const list = new List(attrs.map(Leaf.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Leaf.createList\\` only accepts arrays or lists, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Leaf` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Leaf}\n   */\n\n  static fromJSON(object) {\n    const { text = '', marks = [] } = object\n\n    const leaf = new Leaf({\n      text,\n      marks: new Set(marks.map(Mark.fromJSON)),\n    })\n\n    return leaf\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Leaf.fromJSON\n\n  /**\n   * Check if `any` is a `Leaf`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isLeaf(any) {\n    return !!(any && any[MODEL_TYPES.LEAF])\n  }\n\n  /**\n   * Check if `any` is a list of leaves.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isLeafList(any) {\n    return List.isList(any) && any.every(item => Leaf.isLeaf(item))\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'leaf'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Return leaf as a list of characters\n   *\n   * @return {List<Character>}\n   */\n\n  getCharacters() {\n    const { marks } = this\n    const characters = Character.createList(\n      this.text.split('').map(char => {\n        return Character.create({\n          text: char,\n          marks,\n        })\n      })\n    )\n\n    return characters\n  }\n\n  /**\n   * Return a JSON representation of the leaf.\n   *\n   * @return {Object}\n   */\n\n  toJSON() {\n    const object = {\n      object: this.object,\n      text: this.text,\n      marks: this.marks.toArray().map(m => m.toJSON()),\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS() {\n    return this.toJSON()\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nLeaf.prototype[MODEL_TYPES.LEAF] = true\n\n/**\n * Export.\n *\n * @type {Leaf}\n */\n\nexport default Leaf\n","/**\n * An auto-incrementing index for generating keys.\n *\n * @type {Number}\n */\n\nlet n\n\n/**\n * The global key generating function.\n *\n * @type {Function}\n */\n\nlet generate\n\n/**\n * Generate a key.\n *\n * @return {String}\n */\n\nfunction generateKey() {\n  return generate()\n}\n\n/**\n * Set a different unique ID generating `function`.\n *\n * @param {Function} func\n */\n\nfunction setKeyGenerator(func) {\n  generate = func\n}\n\n/**\n * Reset the key generating function to its initial state.\n */\n\nfunction resetKeyGenerator() {\n  n = 0\n  generate = () => `${n++}`\n}\n\n/**\n * Set the initial state.\n */\n\nresetKeyGenerator()\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default generateKey\nexport { setKeyGenerator, resetKeyGenerator }\n","import isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { List, OrderedSet, Record, Set, is } from 'immutable'\n\nimport Character from './character'\nimport Mark from './mark'\nimport Leaf from './leaf'\nimport MODEL_TYPES from '../constants/model-types'\nimport generateKey from '../utils/generate-key'\nimport memoize from '../utils/memoize'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  characters: new List(),\n  key: undefined,\n}\n\n/**\n * Text.\n *\n * @type {Text}\n */\n\nclass Text extends Record(DEFAULTS) {\n  /**\n   * Create a new `Text` with `attrs`.\n   *\n   * @param {Object|Array|List|String|Text} attrs\n   * @return {Text}\n   */\n\n  static create(attrs = '') {\n    if (Text.isText(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs == 'string') {\n      attrs = { leaves: [{ text: attrs }] }\n    }\n\n    if (isPlainObject(attrs)) {\n      if (attrs.text) {\n        const { text, marks, key } = attrs\n        attrs = { key, leaves: [{ text, marks }] }\n      }\n\n      return Text.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Text.create\\` only accepts objects, arrays, strings or texts, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Texts` from `elements`.\n   *\n   * @param {Array<Text|Object>|List<Text|Object>} elements\n   * @return {List<Text>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Text.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Text.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a `Text` from a JSON `object`.\n   *\n   * @param {Object|Text} object\n   * @return {Text}\n   */\n\n  static fromJSON(object) {\n    if (Text.isText(object)) {\n      return object\n    }\n\n    const { leaves = [], key = generateKey() } = object\n\n    const characters = leaves\n      .map(Leaf.fromJSON)\n      .reduce((l, r) => l.concat(r.getCharacters()), new List())\n\n    const node = new Text({\n      characters,\n      key,\n    })\n\n    return node\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Text.fromJSON\n\n  /**\n   * Check if `any` is a `Text`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isText(any) {\n    return !!(any && any[MODEL_TYPES.TEXT])\n  }\n\n  /**\n   * Check if `any` is a list of texts.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isTextList(any) {\n    return List.isList(any) && any.every(item => Text.isText(item))\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'text'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Is the node empty?\n   *\n   * @return {Boolean}\n   */\n\n  get isEmpty() {\n    return this.text == ''\n  }\n\n  /**\n   * Get the concatenated text of the node.\n   *\n   * @return {String}\n   */\n\n  get text() {\n    return this.characters.reduce((string, char) => string + char.text, '')\n  }\n\n  /**\n   * Add a `mark` at `index` and `length`.\n   *\n   * @param {Number} index\n   * @param {Number} length\n   * @param {Mark} mark\n   * @return {Text}\n   */\n\n  addMark(index, length, mark) {\n    const marks = new Set([mark])\n    return this.addMarks(index, length, marks)\n  }\n\n  /**\n   * Add a `set` of marks at `index` and `length`.\n   *\n   * @param {Number} index\n   * @param {Number} length\n   * @param {Set<Mark>} set\n   * @return {Text}\n   */\n\n  addMarks(index, length, set) {\n    const characters = this.characters.map((char, i) => {\n      if (i < index) return char\n      if (i >= index + length) return char\n      let { marks } = char\n      marks = marks.union(set)\n      char = char.set('marks', marks)\n      return char\n    })\n\n    return this.set('characters', characters)\n  }\n\n  /**\n   * Derive a set of decorated characters with `decorations`.\n   *\n   * @param {List<Decoration>} decorations\n   * @return {List<Character>}\n   */\n\n  getDecoratedCharacters(decorations) {\n    let node = this\n    const { key, characters } = node\n\n    // PERF: Exit early if there are no characters to be decorated.\n    if (characters.size == 0) return characters\n\n    decorations.forEach(range => {\n      const { startKey, endKey, startOffset, endOffset, marks } = range\n      const hasStart = startKey == key\n      const hasEnd = endKey == key\n      const index = hasStart ? startOffset : 0\n      const length = hasEnd ? endOffset - index : characters.size\n      node = node.addMarks(index, length, marks)\n    })\n\n    return node.characters\n  }\n\n  /**\n   * Get the decorations for the node from a `schema`.\n   *\n   * @param {Schema} schema\n   * @return {Array}\n   */\n\n  getDecorations(schema) {\n    return schema.__getDecorations(this)\n  }\n\n  /**\n   * Derive the leaves for a list of `characters`.\n   *\n   * @param {Array|Void} decorations (optional)\n   * @return {List<Leaf>}\n   */\n\n  getLeaves(decorations = []) {\n    const characters = this.getDecoratedCharacters(decorations)\n    let leaves = []\n\n    // PERF: cache previous values for faster lookup.\n    let prevChar\n    let prevLeaf\n\n    // If there are no characters, return one empty range.\n    if (characters.size == 0) {\n      leaves.push({})\n    } else {\n      // Otherwise, loop the characters and build the leaves...\n      characters.forEach((char, i) => {\n        const { marks, text } = char\n\n        // The first one can always just be created.\n        if (i == 0) {\n          prevChar = char\n          prevLeaf = { text, marks }\n          leaves.push(prevLeaf)\n          return\n        }\n\n        // Otherwise, compare the current and previous marks.\n        const prevMarks = prevChar.marks\n        const isSame = is(marks, prevMarks)\n\n        // If the marks are the same, add the text to the previous range.\n        if (isSame) {\n          prevChar = char\n          prevLeaf.text += text\n          return\n        }\n\n        // Otherwise, create a new range.\n        prevChar = char\n        prevLeaf = { text, marks }\n        leaves.push(prevLeaf)\n      }, [])\n    }\n\n    // PERF: convert the leaves to immutable objects after iterating.\n    leaves = new List(leaves.map(object => new Leaf(object)))\n\n    // Return the leaves.\n    return leaves\n  }\n\n  /**\n   * Get all of the marks on the text.\n   *\n   * @return {OrderedSet<Mark>}\n   */\n\n  getMarks() {\n    const array = this.getMarksAsArray()\n    return new OrderedSet(array)\n  }\n\n  /**\n   * Get all of the marks on the text as an array\n   *\n   * @return {Array}\n   */\n\n  getMarksAsArray() {\n    return this.characters.reduce((array, char) => {\n      return array.concat(char.marks.toArray())\n    }, [])\n  }\n\n  /**\n   * Get the marks on the text at `index`.\n   *\n   * @param {Number} index\n   * @return {Set<Mark>}\n   */\n\n  getMarksAtIndex(index) {\n    if (index == 0) return Mark.createSet()\n    const { characters } = this\n    const char = characters.get(index - 1)\n    if (!char) return Mark.createSet()\n    return char.marks\n  }\n\n  /**\n   * Get a node by `key`, to parallel other nodes.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getNode(key) {\n    return this.key == key ? this : null\n  }\n\n  /**\n   * Check if the node has a node by `key`, to parallel other nodes.\n   *\n   * @param {String} key\n   * @return {Boolean}\n   */\n\n  hasNode(key) {\n    return !!this.getNode(key)\n  }\n\n  /**\n   * Insert `text` at `index`.\n   *\n   * @param {Numbder} index\n   * @param {String} text\n   * @param {String} marks (optional)\n   * @return {Text}\n   */\n\n  insertText(index, text, marks) {\n    let { characters } = this\n    const chars = Character.createList(\n      text.split('').map(char => ({ text: char, marks }))\n    )\n\n    characters = characters\n      .slice(0, index)\n      .concat(chars)\n      .concat(characters.slice(index))\n\n    return this.set('characters', characters)\n  }\n\n  /**\n   * Regenerate the node's key.\n   *\n   * @return {Text}\n   */\n\n  regenerateKey() {\n    const key = generateKey()\n    return this.set('key', key)\n  }\n\n  /**\n   * Remove a `mark` at `index` and `length`.\n   *\n   * @param {Number} index\n   * @param {Number} length\n   * @param {Mark} mark\n   * @return {Text}\n   */\n\n  removeMark(index, length, mark) {\n    const characters = this.characters.map((char, i) => {\n      if (i < index) return char\n      if (i >= index + length) return char\n      let { marks } = char\n      marks = marks.remove(mark)\n      char = char.set('marks', marks)\n      return char\n    })\n\n    return this.set('characters', characters)\n  }\n\n  /**\n   * Remove text from the text node at `index` for `length`.\n   *\n   * @param {Number} index\n   * @param {Number} length\n   * @return {Text}\n   */\n\n  removeText(index, length) {\n    let { characters } = this\n    const start = index\n    const end = index + length\n    characters = characters.filterNot((char, i) => start <= i && i < end)\n    return this.set('characters', characters)\n  }\n\n  /**\n   * Return a JSON representation of the text.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      leaves: this.getLeaves()\n        .toArray()\n        .map(r => r.toJSON()),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS(options) {\n    return this.toJSON(options)\n  }\n\n  /**\n   * Update a `mark` at `index` and `length` with `properties`.\n   *\n   * @param {Number} index\n   * @param {Number} length\n   * @param {Mark} mark\n   * @param {Object} properties\n   * @return {Text}\n   */\n\n  updateMark(index, length, mark, properties) {\n    const newMark = mark.merge(properties)\n\n    const characters = this.characters.map((char, i) => {\n      if (i < index) return char\n      if (i >= index + length) return char\n      let { marks } = char\n      if (!marks.has(mark)) return char\n      marks = marks.remove(mark)\n      marks = marks.add(newMark)\n      char = char.set('marks', marks)\n      return char\n    })\n\n    return this.set('characters', characters)\n  }\n\n  /**\n   * Validate the text node against a `schema`.\n   *\n   * @param {Schema} schema\n   * @return {Object|Void}\n   */\n\n  validate(schema) {\n    return schema.validateNode(this)\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nText.prototype[MODEL_TYPES.TEXT] = true\n\n/**\n * Memoize read methods.\n */\n\nmemoize(Text.prototype, ['getMarks', 'getMarksAsArray'], {\n  takesArguments: false,\n})\n\nmemoize(\n  Text.prototype,\n  [\n    'getDecoratedCharacters',\n    'getDecorations',\n    'getLeaves',\n    'getMarksAtIndex',\n    'validate',\n  ],\n  {\n    takesArguments: true,\n  }\n)\n\n/**\n * Export.\n *\n * @type {Text}\n */\n\nexport default Text\n","/**\n * Check if an `index` of a `text` node is in a `range`.\n *\n * @param {Number} index\n * @param {Text} text\n * @param {Range} range\n * @return {Boolean}\n */\n\nfunction isIndexInRange(index, text, range) {\n  const { startKey, startOffset, endKey, endOffset } = range\n\n  if (text.key == startKey && text.key == endKey) {\n    return startOffset <= index && index < endOffset\n  } else if (text.key == startKey) {\n    return startOffset <= index\n  } else if (text.key == endKey) {\n    return index < endOffset\n  } else {\n    return true\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default isIndexInRange\n","import direction from 'direction'\nimport isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { List, OrderedSet, Set } from 'immutable'\n\nimport Block from './block'\nimport Data from './data'\nimport Document from './document'\nimport Inline from './inline'\nimport Range from './range'\nimport Text from './text'\nimport generateKey from '../utils/generate-key'\nimport isIndexInRange from '../utils/is-index-in-range'\nimport memoize from '../utils/memoize'\n\n/**\n * Node.\n *\n * And interface that `Document`, `Block` and `Inline` all implement, to make\n * working with the recursive node tree easier.\n *\n * @type {Node}\n */\n\nclass Node {\n  /**\n   * Create a new `Node` with `attrs`.\n   *\n   * @param {Object|Node} attrs\n   * @return {Node}\n   */\n\n  static create(attrs = {}) {\n    if (Node.isNode(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      let { object } = attrs\n\n      if (!object && attrs.kind) {\n        logger.deprecate(\n          'slate@0.32.0',\n          'The `kind` property of Slate objects has been renamed to `object`.'\n        )\n        object = attrs.kind\n      }\n\n      switch (object) {\n        case 'block':\n          return Block.create(attrs)\n        case 'document':\n          return Document.create(attrs)\n        case 'inline':\n          return Inline.create(attrs)\n        case 'text':\n          return Text.create(attrs)\n        default: {\n          throw new Error('`Node.create` requires a `object` string.')\n        }\n      }\n    }\n\n    throw new Error(\n      `\\`Node.create\\` only accepts objects or nodes but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Nodes` from an array.\n   *\n   * @param {Array<Object|Node>} elements\n   * @return {List<Node>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Node.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Node.createList\\` only accepts lists or arrays, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable node properties from `attrs`.\n   *\n   * @param {Object|String|Node} attrs\n   * @return {Object}\n   */\n\n  static createProperties(attrs = {}) {\n    if (Block.isBlock(attrs) || Inline.isInline(attrs)) {\n      return {\n        data: attrs.data,\n        isVoid: attrs.isVoid,\n        type: attrs.type,\n      }\n    }\n\n    if (typeof attrs == 'string') {\n      return { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      const props = {}\n      if ('type' in attrs) props.type = attrs.type\n      if ('data' in attrs) props.data = Data.create(attrs.data)\n      if ('isVoid' in attrs) props.isVoid = attrs.isVoid\n      return props\n    }\n\n    throw new Error(\n      `\\`Node.createProperties\\` only accepts objects, strings, blocks or inlines, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Node` from a JSON `value`.\n   *\n   * @param {Object} value\n   * @return {Node}\n   */\n\n  static fromJSON(value) {\n    let { object } = value\n\n    if (!object && value.kind) {\n      logger.deprecate(\n        'slate@0.32.0',\n        'The `kind` property of Slate objects has been renamed to `object`.'\n      )\n      object = value.kind\n    }\n\n    switch (object) {\n      case 'block':\n        return Block.fromJSON(value)\n      case 'document':\n        return Document.fromJSON(value)\n      case 'inline':\n        return Inline.fromJSON(value)\n      case 'text':\n        return Text.fromJSON(value)\n      default: {\n        throw new Error(\n          `\\`Node.fromJSON\\` requires an \\`object\\` of either 'block', 'document', 'inline' or 'text', but you passed: ${value}`\n        )\n      }\n    }\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Node.fromJSON\n\n  /**\n   * Check if `any` is a `Node`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isNode(any) {\n    return (\n      Block.isBlock(any) ||\n      Document.isDocument(any) ||\n      Inline.isInline(any) ||\n      Text.isText(any)\n    )\n  }\n\n  /**\n   * Check if `any` is a list of nodes.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isNodeList(any) {\n    return List.isList(any) && any.every(item => Node.isNode(item))\n  }\n\n  /**\n   * True if the node has both descendants in that order, false otherwise. The\n   * order is depth-first, post-order.\n   *\n   * @param {String} first\n   * @param {String} second\n   * @return {Boolean}\n   */\n\n  areDescendantsSorted(first, second) {\n    first = assertKey(first)\n    second = assertKey(second)\n\n    const keys = this.getKeysAsArray()\n    const firstIndex = keys.indexOf(first)\n    const secondIndex = keys.indexOf(second)\n    if (firstIndex == -1 || secondIndex == -1) return null\n\n    return firstIndex < secondIndex\n  }\n\n  /**\n   * Assert that a node has a child by `key` and return it.\n   *\n   * @param {String} key\n   * @return {Node}\n   */\n\n  assertChild(key) {\n    const child = this.getChild(key)\n\n    if (!child) {\n      key = assertKey(key)\n      throw new Error(`Could not find a child node with key \"${key}\".`)\n    }\n\n    return child\n  }\n\n  /**\n   * Assert that a node has a descendant by `key` and return it.\n   *\n   * @param {String} key\n   * @return {Node}\n   */\n\n  assertDescendant(key) {\n    const descendant = this.getDescendant(key)\n\n    if (!descendant) {\n      key = assertKey(key)\n      throw new Error(`Could not find a descendant node with key \"${key}\".`)\n    }\n\n    return descendant\n  }\n\n  /**\n   * Assert that a node's tree has a node by `key` and return it.\n   *\n   * @param {String} key\n   * @return {Node}\n   */\n\n  assertNode(key) {\n    const node = this.getNode(key)\n\n    if (!node) {\n      key = assertKey(key)\n      throw new Error(`Could not find a node with key \"${key}\".`)\n    }\n\n    return node\n  }\n\n  /**\n   * Assert that a node exists at `path` and return it.\n   *\n   * @param {Array} path\n   * @return {Node}\n   */\n\n  assertPath(path) {\n    const descendant = this.getDescendantAtPath(path)\n\n    if (!descendant) {\n      throw new Error(`Could not find a descendant at path \"${path}\".`)\n    }\n\n    return descendant\n  }\n\n  /**\n   * Recursively filter all descendant nodes with `iterator`.\n   *\n   * @param {Function} iterator\n   * @return {List<Node>}\n   */\n\n  filterDescendants(iterator) {\n    const matches = []\n\n    this.forEachDescendant((node, i, nodes) => {\n      if (iterator(node, i, nodes)) matches.push(node)\n    })\n\n    return List(matches)\n  }\n\n  /**\n   * Recursively find all descendant nodes by `iterator`.\n   *\n   * @param {Function} iterator\n   * @return {Node|Null}\n   */\n\n  findDescendant(iterator) {\n    let found = null\n\n    this.forEachDescendant((node, i, nodes) => {\n      if (iterator(node, i, nodes)) {\n        found = node\n        return false\n      }\n    })\n\n    return found\n  }\n\n  /**\n   * Recursively iterate over all descendant nodes with `iterator`. If the\n   * iterator returns false it will break the loop.\n   *\n   * @param {Function} iterator\n   */\n\n  forEachDescendant(iterator) {\n    let ret\n\n    this.nodes.forEach((child, i, nodes) => {\n      if (iterator(child, i, nodes) === false) {\n        ret = false\n        return false\n      }\n\n      if (child.object != 'text') {\n        ret = child.forEachDescendant(iterator)\n        return ret\n      }\n    })\n\n    return ret\n  }\n\n  /**\n   * Get the path of ancestors of a descendant node by `key`.\n   *\n   * @param {String|Node} key\n   * @return {List<Node>|Null}\n   */\n\n  getAncestors(key) {\n    key = assertKey(key)\n\n    if (key == this.key) return List()\n    if (this.hasChild(key)) return List([this])\n\n    let ancestors\n    this.nodes.find(node => {\n      if (node.object == 'text') return false\n      ancestors = node.getAncestors(key)\n      return ancestors\n    })\n\n    if (ancestors) {\n      return ancestors.unshift(this)\n    } else {\n      return null\n    }\n  }\n\n  /**\n   * Get the leaf block descendants of the node.\n   *\n   * @return {List<Node>}\n   */\n\n  getBlocks() {\n    const array = this.getBlocksAsArray()\n    return new List(array)\n  }\n\n  /**\n   * Get the leaf block descendants of the node.\n   *\n   * @return {List<Node>}\n   */\n\n  getBlocksAsArray() {\n    return this.nodes.reduce((array, child) => {\n      if (child.object != 'block') return array\n      if (!child.isLeafBlock()) return array.concat(child.getBlocksAsArray())\n      array.push(child)\n      return array\n    }, [])\n  }\n\n  /**\n   * Get the leaf block descendants in a `range`.\n   *\n   * @param {Range} range\n   * @return {List<Node>}\n   */\n\n  getBlocksAtRange(range) {\n    const array = this.getBlocksAtRangeAsArray(range)\n    // Eliminate duplicates by converting to an `OrderedSet` first.\n    return new List(new OrderedSet(array))\n  }\n\n  /**\n   * Get the leaf block descendants in a `range` as an array\n   *\n   * @param {Range} range\n   * @return {Array}\n   */\n\n  getBlocksAtRangeAsArray(range) {\n    range = range.normalize(this)\n    if (range.isUnset) return []\n\n    const { startKey, endKey } = range\n    const startBlock = this.getClosestBlock(startKey)\n\n    // PERF: the most common case is when the range is in a single block node,\n    // where we can avoid a lot of iterating of the tree.\n    if (startKey == endKey) return [startBlock]\n\n    const endBlock = this.getClosestBlock(endKey)\n    const blocks = this.getBlocksAsArray()\n    const start = blocks.indexOf(startBlock)\n    const end = blocks.indexOf(endBlock)\n    return blocks.slice(start, end + 1)\n  }\n\n  /**\n   * Get all of the leaf blocks that match a `type`.\n   *\n   * @param {String} type\n   * @return {List<Node>}\n   */\n\n  getBlocksByType(type) {\n    const array = this.getBlocksByTypeAsArray(type)\n    return new List(array)\n  }\n\n  /**\n   * Get all of the leaf blocks that match a `type` as an array\n   *\n   * @param {String} type\n   * @return {Array}\n   */\n\n  getBlocksByTypeAsArray(type) {\n    return this.nodes.reduce((array, node) => {\n      if (node.object != 'block') {\n        return array\n      } else if (node.isLeafBlock() && node.type == type) {\n        array.push(node)\n        return array\n      } else {\n        return array.concat(node.getBlocksByTypeAsArray(type))\n      }\n    }, [])\n  }\n\n  /**\n   * Get all of the characters for every text node.\n   *\n   * @return {List<Character>}\n   */\n\n  getCharacters() {\n    const array = this.getCharactersAsArray()\n    return new List(array)\n  }\n\n  /**\n   * Get all of the characters for every text node as an array\n   *\n   * @return {Array}\n   */\n\n  getCharactersAsArray() {\n    return this.nodes.reduce((arr, node) => {\n      return node.object == 'text'\n        ? arr.concat(node.characters.toArray())\n        : arr.concat(node.getCharactersAsArray())\n    }, [])\n  }\n\n  /**\n   * Get a list of the characters in a `range`.\n   *\n   * @param {Range} range\n   * @return {List<Character>}\n   */\n\n  getCharactersAtRange(range) {\n    const array = this.getCharactersAtRangeAsArray(range)\n    return new List(array)\n  }\n\n  /**\n   * Get a list of the characters in a `range` as an array.\n   *\n   * @param {Range} range\n   * @return {Array}\n   */\n\n  getCharactersAtRangeAsArray(range) {\n    range = range.normalize(this)\n    if (range.isUnset) return []\n\n    return this.getTextsAtRange(range).reduce((arr, text) => {\n      const chars = text.characters\n        .filter((char, i) => isIndexInRange(i, text, range))\n        .toArray()\n\n      return arr.concat(chars)\n    }, [])\n  }\n\n  /**\n   * Get a child node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getChild(key) {\n    key = assertKey(key)\n    return this.nodes.find(node => node.key == key)\n  }\n\n  /**\n   * Get closest parent of node by `key` that matches `iterator`.\n   *\n   * @param {String} key\n   * @param {Function} iterator\n   * @return {Node|Null}\n   */\n\n  getClosest(key, iterator) {\n    key = assertKey(key)\n    const ancestors = this.getAncestors(key)\n    if (!ancestors) {\n      throw new Error(`Could not find a descendant node with key \"${key}\".`)\n    }\n\n    // Exclude this node itself.\n    return ancestors.rest().findLast(iterator)\n  }\n\n  /**\n   * Get the closest block parent of a `node`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getClosestBlock(key) {\n    return this.getClosest(key, parent => parent.object == 'block')\n  }\n\n  /**\n   * Get the closest inline parent of a `node`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getClosestInline(key) {\n    return this.getClosest(key, parent => parent.object == 'inline')\n  }\n\n  /**\n   * Get the closest void parent of a `node`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getClosestVoid(key) {\n    return this.getClosest(key, parent => parent.isVoid)\n  }\n\n  /**\n   * Get the common ancestor of nodes `one` and `two` by keys.\n   *\n   * @param {String} one\n   * @param {String} two\n   * @return {Node}\n   */\n\n  getCommonAncestor(one, two) {\n    one = assertKey(one)\n    two = assertKey(two)\n\n    if (one == this.key) return this\n    if (two == this.key) return this\n\n    this.assertDescendant(one)\n    this.assertDescendant(two)\n    let ancestors = new List()\n    let oneParent = this.getParent(one)\n    let twoParent = this.getParent(two)\n\n    while (oneParent) {\n      ancestors = ancestors.push(oneParent)\n      oneParent = this.getParent(oneParent.key)\n    }\n\n    while (twoParent) {\n      if (ancestors.includes(twoParent)) return twoParent\n      twoParent = this.getParent(twoParent.key)\n    }\n  }\n\n  /**\n   * Get the decorations for the node from a `stack`.\n   *\n   * @param {Stack} stack\n   * @return {List}\n   */\n\n  getDecorations(stack) {\n    const decorations = stack.find('decorateNode', this)\n    const list = Range.createList(decorations || [])\n    return list\n  }\n\n  /**\n   * Get the depth of a child node by `key`, with optional `startAt`.\n   *\n   * @param {String} key\n   * @param {Number} startAt (optional)\n   * @return {Number} depth\n   */\n\n  getDepth(key, startAt = 1) {\n    this.assertDescendant(key)\n    if (this.hasChild(key)) return startAt\n    return this.getFurthestAncestor(key).getDepth(key, startAt + 1)\n  }\n\n  /**\n   * Get a descendant node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getDescendant(key) {\n    key = assertKey(key)\n    let descendantFound = null\n\n    const found = this.nodes.find(node => {\n      if (node.key === key) {\n        return node\n      } else if (node.object !== 'text') {\n        descendantFound = node.getDescendant(key)\n        return descendantFound\n      } else {\n        return false\n      }\n    })\n\n    return descendantFound || found\n  }\n\n  /**\n   * Get a descendant by `path`.\n   *\n   * @param {Array} path\n   * @return {Node|Null}\n   */\n\n  getDescendantAtPath(path) {\n    let descendant = this\n\n    for (const index of path) {\n      if (!descendant) return\n      if (!descendant.nodes) return\n      descendant = descendant.nodes.get(index)\n    }\n\n    return descendant\n  }\n\n  /**\n   * Get the first child text node.\n   *\n   * @return {Node|Null}\n   */\n\n  getFirstText() {\n    let descendantFound = null\n\n    const found = this.nodes.find(node => {\n      if (node.object == 'text') return true\n      descendantFound = node.getFirstText()\n      return descendantFound\n    })\n\n    return descendantFound || found\n  }\n\n  /**\n   * Get a fragment of the node at a `range`.\n   *\n   * @param {Range} range\n   * @return {Document}\n   */\n\n  getFragmentAtRange(range) {\n    range = range.normalize(this)\n    if (range.isUnset) return Document.create()\n\n    let node = this\n\n    // Make sure the children exist.\n    const { startKey, startOffset, endKey, endOffset } = range\n    const startText = node.assertDescendant(startKey)\n    const endText = node.assertDescendant(endKey)\n\n    // Split at the start and end.\n    let child = startText\n    let previous\n    let parent\n\n    while ((parent = node.getParent(child.key))) {\n      const index = parent.nodes.indexOf(child)\n      const position =\n        child.object == 'text' ? startOffset : child.nodes.indexOf(previous)\n\n      parent = parent.splitNode(index, position)\n      node = node.updateNode(parent)\n      previous = parent.nodes.get(index + 1)\n      child = parent\n    }\n\n    child = startKey == endKey ? node.getNextText(startKey) : endText\n\n    while ((parent = node.getParent(child.key))) {\n      const index = parent.nodes.indexOf(child)\n      const position =\n        child.object == 'text'\n          ? startKey == endKey ? endOffset - startOffset : endOffset\n          : child.nodes.indexOf(previous)\n\n      parent = parent.splitNode(index, position)\n      node = node.updateNode(parent)\n      previous = parent.nodes.get(index + 1)\n      child = parent\n    }\n\n    // Get the start and end nodes.\n    const startNode = node.getNextSibling(\n      node.getFurthestAncestor(startKey).key\n    )\n    const endNode =\n      startKey == endKey\n        ? node.getNextSibling(\n            node.getNextSibling(node.getFurthestAncestor(endKey).key).key\n          )\n        : node.getNextSibling(node.getFurthestAncestor(endKey).key)\n\n    // Get children range of nodes from start to end nodes\n    const startIndex = node.nodes.indexOf(startNode)\n    const endIndex = node.nodes.indexOf(endNode)\n    const nodes = node.nodes.slice(startIndex, endIndex)\n\n    // Return a new document fragment.\n    return Document.create({ nodes })\n  }\n\n  /**\n   * Get the furthest parent of a node by `key` that matches an `iterator`.\n   *\n   * @param {String} key\n   * @param {Function} iterator\n   * @return {Node|Null}\n   */\n\n  getFurthest(key, iterator) {\n    const ancestors = this.getAncestors(key)\n    if (!ancestors) {\n      key = assertKey(key)\n      throw new Error(`Could not find a descendant node with key \"${key}\".`)\n    }\n\n    // Exclude this node itself\n    return ancestors.rest().find(iterator)\n  }\n\n  /**\n   * Get the furthest block parent of a node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getFurthestBlock(key) {\n    return this.getFurthest(key, node => node.object == 'block')\n  }\n\n  /**\n   * Get the furthest inline parent of a node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getFurthestInline(key) {\n    return this.getFurthest(key, node => node.object == 'inline')\n  }\n\n  /**\n   * Get the furthest ancestor of a node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getFurthestAncestor(key) {\n    key = assertKey(key)\n    return this.nodes.find(node => {\n      if (node.key == key) return true\n      if (node.object == 'text') return false\n      return node.hasDescendant(key)\n    })\n  }\n\n  /**\n   * Get the furthest ancestor of a node by `key` that has only one child.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getFurthestOnlyChildAncestor(key) {\n    const ancestors = this.getAncestors(key)\n\n    if (!ancestors) {\n      key = assertKey(key)\n      throw new Error(`Could not find a descendant node with key \"${key}\".`)\n    }\n\n    return (\n      ancestors\n        // Skip this node...\n        .skipLast()\n        // Take parents until there are more than one child...\n        .reverse()\n        .takeUntil(p => p.nodes.size > 1)\n        // And pick the highest.\n        .last()\n    )\n  }\n\n  /**\n   * Get the closest inline nodes for each text node in the node.\n   *\n   * @return {List<Node>}\n   */\n\n  getInlines() {\n    const array = this.getInlinesAsArray()\n    return new List(array)\n  }\n\n  /**\n   * Get the closest inline nodes for each text node in the node, as an array.\n   *\n   * @return {List<Node>}\n   */\n\n  getInlinesAsArray() {\n    let array = []\n\n    this.nodes.forEach(child => {\n      if (child.object == 'text') return\n      if (child.isLeafInline()) {\n        array.push(child)\n      } else {\n        array = array.concat(child.getInlinesAsArray())\n      }\n    })\n\n    return array\n  }\n\n  /**\n   * Get the closest inline nodes for each text node in a `range`.\n   *\n   * @param {Range} range\n   * @return {List<Node>}\n   */\n\n  getInlinesAtRange(range) {\n    const array = this.getInlinesAtRangeAsArray(range)\n    // Remove duplicates by converting it to an `OrderedSet` first.\n    return new List(new OrderedSet(array))\n  }\n\n  /**\n   * Get the closest inline nodes for each text node in a `range` as an array.\n   *\n   * @param {Range} range\n   * @return {Array}\n   */\n\n  getInlinesAtRangeAsArray(range) {\n    range = range.normalize(this)\n    if (range.isUnset) return []\n\n    return this.getTextsAtRangeAsArray(range)\n      .map(text => this.getClosestInline(text.key))\n      .filter(exists => exists)\n  }\n\n  /**\n   * Get all of the leaf inline nodes that match a `type`.\n   *\n   * @param {String} type\n   * @return {List<Node>}\n   */\n\n  getInlinesByType(type) {\n    const array = this.getInlinesByTypeAsArray(type)\n    return new List(array)\n  }\n\n  /**\n   * Get all of the leaf inline nodes that match a `type` as an array.\n   *\n   * @param {String} type\n   * @return {Array}\n   */\n\n  getInlinesByTypeAsArray(type) {\n    return this.nodes.reduce((inlines, node) => {\n      if (node.object == 'text') {\n        return inlines\n      } else if (node.isLeafInline() && node.type == type) {\n        inlines.push(node)\n        return inlines\n      } else {\n        return inlines.concat(node.getInlinesByTypeAsArray(type))\n      }\n    }, [])\n  }\n\n  /**\n   * Return a set of all keys in the node as an array.\n   *\n   * @return {Array<String>}\n   */\n\n  getKeysAsArray() {\n    const keys = []\n\n    this.forEachDescendant(desc => {\n      keys.push(desc.key)\n    })\n\n    return keys\n  }\n\n  /**\n   * Return a set of all keys in the node.\n   *\n   * @return {Set<String>}\n   */\n\n  getKeys() {\n    const keys = this.getKeysAsArray()\n    return new Set(keys)\n  }\n\n  /**\n   * Get the last child text node.\n   *\n   * @return {Node|Null}\n   */\n\n  getLastText() {\n    let descendantFound = null\n\n    const found = this.nodes.findLast(node => {\n      if (node.object == 'text') return true\n      descendantFound = node.getLastText()\n      return descendantFound\n    })\n\n    return descendantFound || found\n  }\n\n  /**\n   * Get all of the marks for all of the characters of every text node.\n   *\n   * @return {Set<Mark>}\n   */\n\n  getMarks() {\n    const array = this.getMarksAsArray()\n    return new Set(array)\n  }\n\n  /**\n   * Get all of the marks for all of the characters of every text node.\n   *\n   * @return {OrderedSet<Mark>}\n   */\n\n  getOrderedMarks() {\n    const array = this.getMarksAsArray()\n    return new OrderedSet(array)\n  }\n\n  /**\n   * Get all of the marks as an array.\n   *\n   * @return {Array}\n   */\n\n  getMarksAsArray() {\n    return this.nodes.reduce((marks, node) => {\n      return marks.concat(node.getMarksAsArray())\n    }, [])\n  }\n\n  /**\n   * Get a set of the marks in a `range`.\n   *\n   * @param {Range} range\n   * @return {Set<Mark>}\n   */\n\n  getMarksAtRange(range) {\n    const array = this.getMarksAtRangeAsArray(range)\n    return new Set(array)\n  }\n\n  /**\n   * Get a set of the marks in a `range`.\n   *\n   * @param {Range} range\n   * @return {Set<Mark>}\n   */\n\n  getInsertMarksAtRange(range) {\n    const array = this.getInsertMarksAtRangeAsArray(range)\n    return new Set(array)\n  }\n\n  /**\n   * Get a set of the marks in a `range`.\n   *\n   * @param {Range} range\n   * @return {OrderedSet<Mark>}\n   */\n\n  getOrderedMarksAtRange(range) {\n    const array = this.getMarksAtRangeAsArray(range)\n    return new OrderedSet(array)\n  }\n\n  /**\n   * Get a set of the active marks in a `range`.\n   *\n   * @param {Range} range\n   * @return {Set<Mark>}\n   */\n\n  getActiveMarksAtRange(range) {\n    const array = this.getActiveMarksAtRangeAsArray(range)\n    return new Set(array)\n  }\n\n  /**\n   * Get a set of the marks in a `range`, by unioning.\n   *\n   * @param {Range} range\n   * @return {Array}\n   */\n\n  getMarksAtRangeAsArray(range) {\n    range = range.normalize(this)\n    if (range.isUnset) return []\n    if (range.isCollapsed) return this.getMarksAtCollapsedRangeAsArray(range)\n\n    return this.getCharactersAtRange(range).reduce((memo, char) => {\n      if (char) {\n        char.marks.toArray().forEach(c => memo.push(c))\n      }\n      return memo\n    }, [])\n  }\n\n  /**\n   * Get a set of the marks in a `range` for insertion behavior.\n   *\n   * @param {Range} range\n   * @return {Array}\n   */\n\n  getInsertMarksAtRangeAsArray(range) {\n    range = range.normalize(this)\n    if (range.isUnset) return []\n    if (range.isCollapsed) return this.getMarksAtCollapsedRangeAsArray(range)\n\n    const text = this.getDescendant(range.startKey)\n    const char = text.characters.get(range.startOffset)\n    if (!char) return []\n\n    return char.marks.toArray()\n  }\n\n  /**\n   * Get a set of marks in a `range`, by treating it as collapsed.\n   *\n   * @param {Range} range\n   * @return {Array}\n   */\n\n  getMarksAtCollapsedRangeAsArray(range) {\n    if (range.isUnset) return []\n\n    const { startKey, startOffset } = range\n\n    if (startOffset == 0) {\n      const previous = this.getPreviousText(startKey)\n      if (!previous || previous.text.length == 0) return []\n      if (\n        this.getClosestBlock(startKey) !== this.getClosestBlock(previous.key)\n      ) {\n        return []\n      }\n      const char = previous.characters.get(previous.text.length - 1)\n      if (!char) return []\n\n      return char.marks.toArray()\n    }\n\n    const text = this.getDescendant(startKey)\n    const char = text.characters.get(startOffset - 1)\n    if (!char) return []\n\n    return char.marks.toArray()\n  }\n\n  /**\n   * Get a set of marks in a `range`, by intersecting.\n   *\n   * @param {Range} range\n   * @return {Array}\n   */\n\n  getActiveMarksAtRangeAsArray(range) {\n    range = range.normalize(this)\n    if (range.isUnset) return []\n    if (range.isCollapsed) return this.getMarksAtCollapsedRangeAsArray(range)\n\n    // Otherwise, get a set of the marks for each character in the range.\n    const chars = this.getCharactersAtRange(range)\n    const first = chars.first()\n    if (!first) return []\n\n    let memo = first.marks\n\n    chars.slice(1).forEach(char => {\n      const marks = char ? char.marks : []\n      memo = memo.intersect(marks)\n      return memo.size != 0\n    })\n\n    return memo.toArray()\n  }\n\n  /**\n   * Get all of the marks that match a `type`.\n   *\n   * @param {String} type\n   * @return {Set<Mark>}\n   */\n\n  getMarksByType(type) {\n    const array = this.getMarksByTypeAsArray(type)\n    return new Set(array)\n  }\n\n  /**\n   * Get all of the marks that match a `type`.\n   *\n   * @param {String} type\n   * @return {OrderedSet<Mark>}\n   */\n\n  getOrderedMarksByType(type) {\n    const array = this.getMarksByTypeAsArray(type)\n    return new OrderedSet(array)\n  }\n\n  /**\n   * Get all of the marks that match a `type` as an array.\n   *\n   * @param {String} type\n   * @return {Array}\n   */\n\n  getMarksByTypeAsArray(type) {\n    return this.nodes.reduce((array, node) => {\n      return node.object == 'text'\n        ? array.concat(node.getMarksAsArray().filter(m => m.type == type))\n        : array.concat(node.getMarksByTypeAsArray(type))\n    }, [])\n  }\n\n  /**\n   * Get the block node before a descendant text node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getNextBlock(key) {\n    const child = this.assertDescendant(key)\n    let last\n\n    if (child.object == 'block') {\n      last = child.getLastText()\n    } else {\n      const block = this.getClosestBlock(key)\n      last = block.getLastText()\n    }\n\n    const next = this.getNextText(last.key)\n    if (!next) return null\n\n    return this.getClosestBlock(next.key)\n  }\n\n  /**\n   * Get the node after a descendant by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getNextSibling(key) {\n    key = assertKey(key)\n\n    const parent = this.getParent(key)\n    const after = parent.nodes.skipUntil(child => child.key == key)\n\n    if (after.size == 0) {\n      throw new Error(`Could not find a child node with key \"${key}\".`)\n    }\n    return after.get(1)\n  }\n\n  /**\n   * Get the text node after a descendant text node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getNextText(key) {\n    key = assertKey(key)\n    return this.getTexts()\n      .skipUntil(text => text.key == key)\n      .get(1)\n  }\n\n  /**\n   * Get a node in the tree by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getNode(key) {\n    key = assertKey(key)\n    return this.key == key ? this : this.getDescendant(key)\n  }\n\n  /**\n   * Get a node in the tree by `path`.\n   *\n   * @param {Array} path\n   * @return {Node|Null}\n   */\n\n  getNodeAtPath(path) {\n    return path.length ? this.getDescendantAtPath(path) : this\n  }\n\n  /**\n   * Get the offset for a descendant text node by `key`.\n   *\n   * @param {String} key\n   * @return {Number}\n   */\n\n  getOffset(key) {\n    this.assertDescendant(key)\n\n    // Calculate the offset of the nodes before the highest child.\n    const child = this.getFurthestAncestor(key)\n    const offset = this.nodes\n      .takeUntil(n => n == child)\n      .reduce((memo, n) => memo + n.text.length, 0)\n\n    // Recurse if need be.\n    return this.hasChild(key) ? offset : offset + child.getOffset(key)\n  }\n\n  /**\n   * Get the offset from a `range`.\n   *\n   * @param {Range} range\n   * @return {Number}\n   */\n\n  getOffsetAtRange(range) {\n    range = range.normalize(this)\n\n    if (range.isUnset) {\n      throw new Error('The range cannot be unset to calculcate its offset.')\n    }\n\n    if (range.isExpanded) {\n      throw new Error('The range must be collapsed to calculcate its offset.')\n    }\n\n    const { startKey, startOffset } = range\n    return this.getOffset(startKey) + startOffset\n  }\n\n  /**\n   * Get the parent of a child node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getParent(key) {\n    if (this.hasChild(key)) return this\n\n    let node = null\n\n    this.nodes.find(child => {\n      if (child.object == 'text') {\n        return false\n      } else {\n        node = child.getParent(key)\n        return node\n      }\n    })\n\n    return node\n  }\n\n  /**\n   * Get the path of a descendant node by `key`.\n   *\n   * @param {String|Node} key\n   * @return {Array}\n   */\n\n  getPath(key) {\n    let child = this.assertNode(key)\n    const ancestors = this.getAncestors(key)\n    const path = []\n\n    ancestors.reverse().forEach(ancestor => {\n      const index = ancestor.nodes.indexOf(child)\n      path.unshift(index)\n      child = ancestor\n    })\n\n    return path\n  }\n\n  /**\n   * Refind the path of node if path is changed.\n   *\n   * @param {Array} path\n   * @param {String} key\n   * @return {Array}\n   */\n\n  refindPath(path, key) {\n    const node = this.getDescendantAtPath(path)\n    if (node && node.key === key) {\n      return path\n    }\n\n    return this.getPath(key)\n  }\n\n  /**\n   *\n   * Refind the node with the same node.key after change.\n   *\n   * @param {Array} path\n   * @param {String} key\n   * @return {Node|Void}\n   */\n\n  refindNode(path, key) {\n    const node = this.getDescendantAtPath(path)\n    if (node && node.key === key) {\n      return node\n    }\n\n    return this.getDescendant(key)\n  }\n\n  /**\n   * Get the placeholder for the node from a `schema`.\n   *\n   * @param {Schema} schema\n   * @return {Component|Void}\n   */\n\n  getPlaceholder(schema) {\n    return schema.__getPlaceholder(this)\n  }\n\n  /**\n   * Get the block node before a descendant text node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getPreviousBlock(key) {\n    const child = this.assertDescendant(key)\n    let first\n\n    if (child.object == 'block') {\n      first = child.getFirstText()\n    } else {\n      const block = this.getClosestBlock(key)\n      first = block.getFirstText()\n    }\n\n    const previous = this.getPreviousText(first.key)\n    if (!previous) return null\n\n    return this.getClosestBlock(previous.key)\n  }\n\n  /**\n   * Get the node before a descendant node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getPreviousSibling(key) {\n    key = assertKey(key)\n    const parent = this.getParent(key)\n    const before = parent.nodes.takeUntil(child => child.key == key)\n\n    if (before.size == parent.nodes.size) {\n      throw new Error(`Could not find a child node with key \"${key}\".`)\n    }\n\n    return before.last()\n  }\n\n  /**\n   * Get the text node before a descendant text node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getPreviousText(key) {\n    key = assertKey(key)\n    return this.getTexts()\n      .takeUntil(text => text.key == key)\n      .last()\n  }\n\n  /**\n   * Get the indexes of the selection for a `range`, given an extra flag for\n   * whether the node `isSelected`, to determine whether not finding matches\n   * means everything is selected or nothing is.\n   *\n   * @param {Range} range\n   * @param {Boolean} isSelected\n   * @return {Object|Null}\n   */\n\n  getSelectionIndexes(range, isSelected = false) {\n    const { startKey, endKey } = range\n\n    // PERF: if we're not selected, or the range is blurred, we can exit early.\n    if (!isSelected || range.isBlurred) {\n      return null\n    }\n\n    // if we've been given an invalid selection we can exit early.\n    if (range.isUnset) {\n      return null\n    }\n\n    // PERF: if the start and end keys are the same, just check for the child\n    // that contains that single key.\n    if (startKey == endKey) {\n      const child = this.getFurthestAncestor(startKey)\n      const index = child ? this.nodes.indexOf(child) : null\n      return { start: index, end: index + 1 }\n    }\n\n    // Otherwise, check all of the children...\n    let start = null\n    let end = null\n\n    this.nodes.forEach((child, i) => {\n      if (child.object == 'text') {\n        if (start == null && child.key == startKey) start = i\n        if (end == null && child.key == endKey) end = i + 1\n      } else {\n        if (start == null && child.hasDescendant(startKey)) start = i\n        if (end == null && child.hasDescendant(endKey)) end = i + 1\n      }\n\n      // PERF: exit early if both start and end have been found.\n      return start == null || end == null\n    })\n\n    if (isSelected && start == null) start = 0\n    if (isSelected && end == null) end = this.nodes.size\n    return start == null ? null : { start, end }\n  }\n\n  /**\n   * Get the concatenated text string of all child nodes.\n   *\n   * @return {String}\n   */\n\n  getText() {\n    return this.nodes.reduce((string, node) => {\n      return string + node.text\n    }, '')\n  }\n\n  /**\n   * Get the descendent text node at an `offset`.\n   *\n   * @param {String} offset\n   * @return {Node|Null}\n   */\n\n  getTextAtOffset(offset) {\n    // PERF: Add a few shortcuts for the obvious cases.\n    if (offset == 0) return this.getFirstText()\n    if (offset == this.text.length) return this.getLastText()\n    if (offset < 0 || offset > this.text.length) return null\n\n    let length = 0\n\n    return this.getTexts().find((node, i, nodes) => {\n      length += node.text.length\n      return length > offset\n    })\n  }\n\n  /**\n   * Get the direction of the node's text.\n   *\n   * @return {String}\n   */\n\n  getTextDirection() {\n    const dir = direction(this.text)\n    return dir == 'neutral' ? undefined : dir\n  }\n\n  /**\n   * Recursively get all of the child text nodes in order of appearance.\n   *\n   * @return {List<Node>}\n   */\n\n  getTexts() {\n    const array = this.getTextsAsArray()\n    return new List(array)\n  }\n\n  /**\n   * Recursively get all the leaf text nodes in order of appearance, as array.\n   *\n   * @return {List<Node>}\n   */\n\n  getTextsAsArray() {\n    let array = []\n\n    this.nodes.forEach(node => {\n      if (node.object == 'text') {\n        array.push(node)\n      } else {\n        array = array.concat(node.getTextsAsArray())\n      }\n    })\n\n    return array\n  }\n\n  /**\n   * Get all of the text nodes in a `range`.\n   *\n   * @param {Range} range\n   * @return {List<Node>}\n   */\n\n  getTextsAtRange(range) {\n    const array = this.getTextsAtRangeAsArray(range)\n    return new List(array)\n  }\n\n  /**\n   * Get all of the text nodes in a `range` as an array.\n   *\n   * @param {Range} range\n   * @return {Array}\n   */\n\n  getTextsAtRangeAsArray(range) {\n    range = range.normalize(this)\n    if (range.isUnset) return []\n\n    const { startKey, endKey } = range\n    const startText = this.getDescendant(startKey)\n\n    // PERF: the most common case is when the range is in a single text node,\n    // where we can avoid a lot of iterating of the tree.\n    if (startKey == endKey) return [startText]\n\n    const endText = this.getDescendant(endKey)\n    const texts = this.getTextsAsArray()\n    const start = texts.indexOf(startText)\n    const end = texts.indexOf(endText)\n    return texts.slice(start, end + 1)\n  }\n\n  /**\n   * Check if a child node exists by `key`.\n   *\n   * @param {String} key\n   * @return {Boolean}\n   */\n\n  hasChild(key) {\n    return !!this.getChild(key)\n  }\n\n  /**\n   * Recursively check if a child node exists by `key`.\n   *\n   * @param {String} key\n   * @return {Boolean}\n   */\n\n  hasDescendant(key) {\n    return !!this.getDescendant(key)\n  }\n\n  /**\n   * Recursively check if a node exists by `key`.\n   *\n   * @param {String} key\n   * @return {Boolean}\n   */\n\n  hasNode(key) {\n    return !!this.getNode(key)\n  }\n\n  /**\n   * Check if a node has a void parent by `key`.\n   *\n   * @param {String} key\n   * @return {Boolean}\n   */\n\n  hasVoidParent(key) {\n    return !!this.getClosest(key, parent => parent.isVoid)\n  }\n\n  /**\n   * Insert a `node` at `index`.\n   *\n   * @param {Number} index\n   * @param {Node} node\n   * @return {Node}\n   */\n\n  insertNode(index, node) {\n    const keys = this.getKeysAsArray()\n\n    if (keys.includes(node.key)) {\n      node = node.regenerateKey()\n    }\n\n    if (node.object != 'text') {\n      node = node.mapDescendants(desc => {\n        return keys.includes(desc.key) ? desc.regenerateKey() : desc\n      })\n    }\n\n    const nodes = this.nodes.insert(index, node)\n    return this.set('nodes', nodes)\n  }\n\n  /**\n   * Check whether the node is in a `range`.\n   *\n   * @param {Range} range\n   * @return {Boolean}\n   */\n\n  isInRange(range) {\n    range = range.normalize(this)\n\n    const node = this\n    const { startKey, endKey, isCollapsed } = range\n\n    // PERF: solve the most common cast where the start or end key are inside\n    // the node, for collapsed selections.\n    if (\n      node.key == startKey ||\n      node.key == endKey ||\n      node.hasDescendant(startKey) ||\n      node.hasDescendant(endKey)\n    ) {\n      return true\n    }\n\n    // PERF: if the selection is collapsed and the previous check didn't return\n    // true, then it must be false.\n    if (isCollapsed) {\n      return false\n    }\n\n    // Otherwise, look through all of the leaf text nodes in the range, to see\n    // if any of them are inside the node.\n    const texts = node.getTextsAtRange(range)\n    let memo = false\n\n    texts.forEach(text => {\n      if (node.hasDescendant(text.key)) memo = true\n      return memo\n    })\n\n    return memo\n  }\n\n  /**\n   * Check whether the node is a leaf block.\n   *\n   * @return {Boolean}\n   */\n\n  isLeafBlock() {\n    return this.object == 'block' && this.nodes.every(n => n.object != 'block')\n  }\n\n  /**\n   * Check whether the node is a leaf inline.\n   *\n   * @return {Boolean}\n   */\n\n  isLeafInline() {\n    return (\n      this.object == 'inline' && this.nodes.every(n => n.object != 'inline')\n    )\n  }\n\n  /**\n   * Merge a children node `first` with another children node `second`.\n   * `first` and `second` will be concatenated in that order.\n   * `first` and `second` must be two Nodes or two Text.\n   *\n   * @param {Node} first\n   * @param {Node} second\n   * @return {Node}\n   */\n\n  mergeNode(withIndex, index) {\n    let node = this\n    let one = node.nodes.get(withIndex)\n    const two = node.nodes.get(index)\n\n    if (one.object != two.object) {\n      throw new Error(\n        `Tried to merge two nodes of different objects: \"${one.object}\" and \"${\n          two.object\n        }\".`\n      )\n    }\n\n    // If the nodes are text nodes, concatenate their characters together.\n    if (one.object == 'text') {\n      const characters = one.characters.concat(two.characters)\n      one = one.set('characters', characters)\n    } else {\n      // Otherwise, concatenate their child nodes together.\n      const nodes = one.nodes.concat(two.nodes)\n      one = one.set('nodes', nodes)\n    }\n\n    node = node.removeNode(index)\n    node = node.removeNode(withIndex)\n    node = node.insertNode(withIndex, one)\n    return node\n  }\n\n  /**\n   * Map all child nodes, updating them in their parents. This method is\n   * optimized to not return a new node if no changes are made.\n   *\n   * @param {Function} iterator\n   * @return {Node}\n   */\n\n  mapChildren(iterator) {\n    let { nodes } = this\n\n    nodes.forEach((node, i) => {\n      const ret = iterator(node, i, this.nodes)\n      if (ret != node) nodes = nodes.set(ret.key, ret)\n    })\n\n    return this.set('nodes', nodes)\n  }\n\n  /**\n   * Map all descendant nodes, updating them in their parents. This method is\n   * optimized to not return a new node if no changes are made.\n   *\n   * @param {Function} iterator\n   * @return {Node}\n   */\n\n  mapDescendants(iterator) {\n    let { nodes } = this\n\n    nodes.forEach((node, i) => {\n      let ret = node\n      if (ret.object != 'text') ret = ret.mapDescendants(iterator)\n      ret = iterator(ret, i, this.nodes)\n      if (ret == node) return\n\n      const index = nodes.indexOf(node)\n      nodes = nodes.set(index, ret)\n    })\n\n    return this.set('nodes', nodes)\n  }\n\n  /**\n   * Regenerate the node's key.\n   *\n   * @return {Node}\n   */\n\n  regenerateKey() {\n    const key = generateKey()\n    return this.set('key', key)\n  }\n\n  /**\n   * Remove a `node` from the children node map.\n   *\n   * @param {String} key\n   * @return {Node}\n   */\n\n  removeDescendant(key) {\n    key = assertKey(key)\n\n    let node = this\n    let parent = node.getParent(key)\n    if (!parent)\n      throw new Error(`Could not find a descendant node with key \"${key}\".`)\n\n    const index = parent.nodes.findIndex(n => n.key === key)\n    const nodes = parent.nodes.splice(index, 1)\n\n    parent = parent.set('nodes', nodes)\n    node = node.updateNode(parent)\n    return node\n  }\n\n  /**\n   * Remove a node at `index`.\n   *\n   * @param {Number} index\n   * @return {Node}\n   */\n\n  removeNode(index) {\n    const nodes = this.nodes.splice(index, 1)\n    return this.set('nodes', nodes)\n  }\n\n  /**\n   * Split a child node by `index` at `position`.\n   *\n   * @param {Number} index\n   * @param {Number} position\n   * @return {Node}\n   */\n\n  splitNode(index, position) {\n    let node = this\n    const child = node.nodes.get(index)\n    let one\n    let two\n\n    // If the child is a text node, the `position` refers to the text offset at\n    // which to split it.\n    if (child.object == 'text') {\n      const befores = child.characters.take(position)\n      const afters = child.characters.skip(position)\n      one = child.set('characters', befores)\n      two = child.set('characters', afters).regenerateKey()\n    } else {\n      // Otherwise, if the child is not a text node, the `position` refers to the\n      // index at which to split its children.\n      const befores = child.nodes.take(position)\n      const afters = child.nodes.skip(position)\n      one = child.set('nodes', befores)\n      two = child.set('nodes', afters).regenerateKey()\n    }\n\n    // Remove the old node and insert the newly split children.\n    node = node.removeNode(index)\n    node = node.insertNode(index, two)\n    node = node.insertNode(index, one)\n    return node\n  }\n\n  /**\n   * Set a new value for a child node by `key`.\n   *\n   * @param {Node} node\n   * @return {Node}\n   */\n\n  updateNode(node) {\n    if (node.key == this.key) {\n      return node\n    }\n\n    let child = this.assertDescendant(node.key)\n    const ancestors = this.getAncestors(node.key)\n\n    ancestors.reverse().forEach(parent => {\n      let { nodes } = parent\n      const index = nodes.indexOf(child)\n      child = parent\n      nodes = nodes.set(index, node)\n      parent = parent.set('nodes', nodes)\n      node = parent\n    })\n\n    return node\n  }\n\n  /**\n   * Validate the node against a `schema`.\n   *\n   * @param {Schema} schema\n   * @return {Function|Null}\n   */\n\n  validate(schema) {\n    return schema.validateNode(this)\n  }\n}\n\n/**\n * Assert a key `arg`.\n *\n * @param {String} arg\n * @return {String}\n */\n\nfunction assertKey(arg) {\n  if (typeof arg == 'string') return arg\n  throw new Error(\n    `Invalid \\`key\\` argument! It must be a key string, but you passed: ${arg}`\n  )\n}\n\n/**\n * Memoize read methods.\n */\n\nmemoize(\n  Node.prototype,\n  [\n    'getBlocksAsArray',\n    'getCharactersAsArray',\n    'getFirstText',\n    'getInlinesAsArray',\n    'getKeysAsArray',\n    'getLastText',\n    'getMarksAsArray',\n    'getText',\n    'getTextDirection',\n    'getTextsAsArray',\n    'isLeafBlock',\n    'isLeafInline',\n  ],\n  {\n    takesArguments: false,\n  }\n)\n\nmemoize(\n  Node.prototype,\n  [\n    'areDescendantsSorted',\n    'getActiveMarksAtRangeAsArray',\n    'getAncestors',\n    'getBlocksAtRangeAsArray',\n    'getBlocksByTypeAsArray',\n    'getCharactersAtRangeAsArray',\n    'getChild',\n    'getClosestBlock',\n    'getClosestInline',\n    'getClosestVoid',\n    'getCommonAncestor',\n    'getDecorations',\n    'getDepth',\n    'getDescendant',\n    'getDescendantAtPath',\n    'getFragmentAtRange',\n    'getFurthestBlock',\n    'getFurthestInline',\n    'getFurthestAncestor',\n    'getFurthestOnlyChildAncestor',\n    'getInlinesAtRangeAsArray',\n    'getInlinesByTypeAsArray',\n    'getMarksAtRangeAsArray',\n    'getInsertMarksAtRangeAsArray',\n    'getMarksByTypeAsArray',\n    'getNextBlock',\n    'getNextSibling',\n    'getNextText',\n    'getNode',\n    'getNodeAtPath',\n    'getOffset',\n    'getOffsetAtRange',\n    'getParent',\n    'getPath',\n    'getPlaceholder',\n    'getPreviousBlock',\n    'getPreviousSibling',\n    'getPreviousText',\n    'getTextAtOffset',\n    'getTextsAtRangeAsArray',\n    'hasVoidParent',\n    'validate',\n  ],\n  {\n    takesArguments: true,\n  }\n)\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Node\n","/**\n * Prevent circular dependencies.\n */\n\nimport './document'\n\n/**\n * Dependencies.\n */\n\nimport isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { List, Map, Record } from 'immutable'\n\nimport Node from './node'\nimport MODEL_TYPES from '../constants/model-types'\nimport generateKey from '../utils/generate-key'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: new Map(),\n  isVoid: false,\n  key: undefined,\n  nodes: new List(),\n  type: undefined,\n}\n\n/**\n * Inline.\n *\n * @type {Inline}\n */\n\nclass Inline extends Record(DEFAULTS) {\n  /**\n   * Create a new `Inline` with `attrs`.\n   *\n   * @param {Object|String|Inline} attrs\n   * @return {Inline}\n   */\n\n  static create(attrs = {}) {\n    if (Inline.isInline(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs == 'string') {\n      attrs = { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Inline.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Inline.create\\` only accepts objects, strings or inlines, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Inlines` from an array.\n   *\n   * @param {Array<Inline|Object>|List<Inline|Object>} elements\n   * @return {List<Inline>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Inline.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Inline.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a `Inline` from a JSON `object`.\n   *\n   * @param {Object|Inline} object\n   * @return {Inline}\n   */\n\n  static fromJSON(object) {\n    if (Inline.isInline(object)) {\n      return object\n    }\n\n    const {\n      data = {},\n      isVoid = false,\n      key = generateKey(),\n      nodes = [],\n      type,\n    } = object\n\n    if (typeof type != 'string') {\n      throw new Error('`Inline.fromJS` requires a `type` string.')\n    }\n\n    const inline = new Inline({\n      key,\n      type,\n      isVoid: !!isVoid,\n      data: new Map(data),\n      nodes: new List(nodes.map(Node.fromJSON)),\n    })\n\n    return inline\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Inline.fromJSON\n\n  /**\n   * Check if `any` is a `Inline`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isInline(any) {\n    return !!(any && any[MODEL_TYPES.INLINE])\n  }\n\n  /**\n   * Check if `any` is a list of inlines.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isInlineList(any) {\n    return List.isList(any) && any.every(item => Inline.isInline(item))\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'inline'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Check if the inline is empty.\n   *\n   * @return {Boolean}\n   */\n\n  get isEmpty() {\n    return this.text == ''\n  }\n\n  /**\n   * Get the concatenated text of all the inline's children.\n   *\n   * @return {String}\n   */\n\n  get text() {\n    return this.getText()\n  }\n\n  /**\n   * Return a JSON representation of the inline.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      type: this.type,\n      isVoid: this.isVoid,\n      data: this.data.toJSON(),\n      nodes: this.nodes.toArray().map(n => n.toJSON(options)),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS(options) {\n    return this.toJSON(options)\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nInline.prototype[MODEL_TYPES.INLINE] = true\n\n/**\n * Mix in `Node` methods.\n */\n\nObject.getOwnPropertyNames(Node.prototype).forEach(method => {\n  if (method == 'constructor') return\n  Inline.prototype[method] = Node.prototype[method]\n})\n\n/**\n * Export.\n *\n * @type {Inline}\n */\n\nexport default Inline\n","/**\n * Prevent circular dependencies.\n */\n\nimport './block'\nimport './inline'\n\n/**\n * Dependencies.\n */\n\nimport isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { List, Map, Record } from 'immutable'\n\nimport Node from './node'\nimport MODEL_TYPES from '../constants/model-types'\nimport generateKey from '../utils/generate-key'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: new Map(),\n  key: undefined,\n  nodes: new List(),\n}\n\n/**\n * Document.\n *\n * @type {Document}\n */\n\nclass Document extends Record(DEFAULTS) {\n  /**\n   * Create a new `Document` with `attrs`.\n   *\n   * @param {Object|Array|List|Text} attrs\n   * @return {Document}\n   */\n\n  static create(attrs = {}) {\n    if (Document.isDocument(attrs)) {\n      return attrs\n    }\n\n    if (List.isList(attrs) || Array.isArray(attrs)) {\n      attrs = { nodes: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Document.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Document.create\\` only accepts objects, arrays, lists or documents, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Document` from a JSON `object`.\n   *\n   * @param {Object|Document} object\n   * @return {Document}\n   */\n\n  static fromJSON(object) {\n    if (Document.isDocument(object)) {\n      return object\n    }\n\n    const { data = {}, key = generateKey(), nodes = [] } = object\n\n    const document = new Document({\n      key,\n      data: new Map(data),\n      nodes: new List(nodes.map(Node.fromJSON)),\n    })\n\n    return document\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Document.fromJSON\n\n  /**\n   * Check if `any` is a `Document`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isDocument(any) {\n    return !!(any && any[MODEL_TYPES.DOCUMENT])\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'document'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Check if the document is empty.\n   *\n   * @return {Boolean}\n   */\n\n  get isEmpty() {\n    return this.text == ''\n  }\n\n  /**\n   * Get the concatenated text of all the document's children.\n   *\n   * @return {String}\n   */\n\n  get text() {\n    return this.getText()\n  }\n\n  /**\n   * Return a JSON representation of the document.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      data: this.data.toJSON(),\n      nodes: this.nodes.toArray().map(n => n.toJSON(options)),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS(options) {\n    return this.toJSON(options)\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nDocument.prototype[MODEL_TYPES.DOCUMENT] = true\n\n/**\n * Mix in `Node` methods.\n */\n\nObject.getOwnPropertyNames(Node.prototype).forEach(method => {\n  if (method == 'constructor') return\n  Document.prototype[method] = Node.prototype[method]\n})\n\n/**\n * Export.\n *\n * @type {Document}\n */\n\nexport default Document\n","/**\n * Prevent circular dependencies.\n */\n\nimport './document'\n\n/**\n * Dependencies.\n */\n\nimport isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { List, Map, Record } from 'immutable'\n\nimport MODEL_TYPES from '../constants/model-types'\nimport Node from './node'\nimport generateKey from '../utils/generate-key'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: new Map(),\n  isVoid: false,\n  key: undefined,\n  nodes: new List(),\n  type: undefined,\n}\n\n/**\n * Block.\n *\n * @type {Block}\n */\n\nclass Block extends Record(DEFAULTS) {\n  /**\n   * Create a new `Block` from `attrs`.\n   *\n   * @param {Object|String|Block} attrs\n   * @return {Block}\n   */\n\n  static create(attrs = {}) {\n    if (Block.isBlock(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs == 'string') {\n      attrs = { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Block.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Block.create\\` only accepts objects, strings or blocks, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Blocks` from `attrs`.\n   *\n   * @param {Array<Block|Object>|List<Block|Object>} attrs\n   * @return {List<Block>}\n   */\n\n  static createList(attrs = []) {\n    if (List.isList(attrs) || Array.isArray(attrs)) {\n      const list = new List(attrs.map(Block.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Block.createList\\` only accepts arrays or lists, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Block` from a JSON `object`.\n   *\n   * @param {Object|Block} object\n   * @return {Block}\n   */\n\n  static fromJSON(object) {\n    if (Block.isBlock(object)) {\n      return object\n    }\n\n    const {\n      data = {},\n      isVoid = false,\n      key = generateKey(),\n      nodes = [],\n      type,\n    } = object\n\n    if (typeof type != 'string') {\n      throw new Error('`Block.fromJSON` requires a `type` string.')\n    }\n\n    const block = new Block({\n      key,\n      type,\n      isVoid: !!isVoid,\n      data: new Map(data),\n      nodes: new List(nodes.map(Node.fromJSON)),\n    })\n\n    return block\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Block.fromJSON\n\n  /**\n   * Check if `any` is a `Block`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isBlock(any) {\n    return !!(any && any[MODEL_TYPES.BLOCK])\n  }\n\n  /**\n   * Check if `any` is a block list.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isBlockList(any) {\n    return List.isList(any) && any.every(item => Block.isBlock(item))\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'block'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Check if the block is empty.\n   *\n   * @return {Boolean}\n   */\n\n  get isEmpty() {\n    return this.text == ''\n  }\n\n  /**\n   * Get the concatenated text of all the block's children.\n   *\n   * @return {String}\n   */\n\n  get text() {\n    return this.getText()\n  }\n\n  /**\n   * Return a JSON representation of the block.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      type: this.type,\n      isVoid: this.isVoid,\n      data: this.data.toJSON(),\n      nodes: this.nodes.toArray().map(n => n.toJSON(options)),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS(options) {\n    return this.toJSON(options)\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nBlock.prototype[MODEL_TYPES.BLOCK] = true\n\n/**\n * Mix in `Node` methods.\n */\n\nObject.getOwnPropertyNames(Node.prototype).forEach(method => {\n  if (method == 'constructor') return\n  Block.prototype[method] = Node.prototype[method]\n})\n\n/**\n * Export.\n *\n * @type {Block}\n */\n\nexport default Block\n","import Block from '../models/block'\nimport Inline from '../models/inline'\nimport Mark from '../models/mark'\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nconst Changes = {}\n\n/**\n * Mix in the changes that pass through to their at-range equivalents because\n * they don't have any effect on the selection.\n */\n\nconst PROXY_TRANSFORMS = [\n  'deleteBackward',\n  'deleteCharBackward',\n  'deleteLineBackward',\n  'deleteWordBackward',\n  'deleteForward',\n  'deleteCharForward',\n  'deleteWordForward',\n  'deleteLineForward',\n  'setBlock',\n  'setInline',\n  'splitInline',\n  'unwrapBlock',\n  'unwrapInline',\n  'wrapBlock',\n  'wrapInline',\n]\n\nPROXY_TRANSFORMS.forEach(method => {\n  Changes[method] = (change, ...args) => {\n    const { value } = change\n    const { selection } = value\n    const methodAtRange = `${method}AtRange`\n    change[methodAtRange](selection, ...args)\n  }\n})\n\n/**\n * Add a `mark` to the characters in the current selection.\n *\n * @param {Change} change\n * @param {Mark} mark\n */\n\nChanges.addMark = (change, mark) => {\n  mark = Mark.create(mark)\n  const { value } = change\n  const { document, selection } = value\n\n  if (selection.isExpanded) {\n    change.addMarkAtRange(selection, mark)\n  } else if (selection.marks) {\n    const marks = selection.marks.add(mark)\n    const sel = selection.set('marks', marks)\n    change.select(sel)\n  } else {\n    const marks = document.getActiveMarksAtRange(selection).add(mark)\n    const sel = selection.set('marks', marks)\n    change.select(sel)\n  }\n}\n\n/**\n * Add a list of `marks` to the characters in the current selection.\n *\n * @param {Change} change\n * @param {Mark} mark\n */\n\nChanges.addMarks = (change, marks) => {\n  marks.forEach(mark => change.addMark(mark))\n}\n\n/**\n * Delete at the current selection.\n *\n * @param {Change} change\n */\n\nChanges.delete = change => {\n  const { value } = change\n  const { selection } = value\n  change.deleteAtRange(selection)\n\n  // Ensure that the selection is collapsed to the start, because in certain\n  // cases when deleting across inline nodes, when splitting the inline node the\n  // end point of the selection will end up after the split point.\n  change.collapseToStart()\n}\n\n/**\n * Insert a `block` at the current selection.\n *\n * @param {Change} change\n * @param {String|Object|Block} block\n */\n\nChanges.insertBlock = (change, block) => {\n  block = Block.create(block)\n  const { value } = change\n  const { selection } = value\n  change.insertBlockAtRange(selection, block)\n\n  // If the node was successfully inserted, update the selection.\n  const node = change.value.document.getNode(block.key)\n  if (node) change.collapseToEndOf(node)\n}\n\n/**\n * Insert a `fragment` at the current selection.\n *\n * @param {Change} change\n * @param {Document} fragment\n */\n\nChanges.insertFragment = (change, fragment) => {\n  if (!fragment.nodes.size) return\n\n  let { value } = change\n  let { document, selection } = value\n  const { startText, endText, startInline } = value\n  const lastText = fragment.getLastText()\n  const lastInline = fragment.getClosestInline(lastText.key)\n  const keys = document.getTexts().map(text => text.key)\n  const isAppending =\n    !startInline ||\n    selection.hasEdgeAtStartOf(startText) ||\n    selection.hasEdgeAtEndOf(endText)\n\n  change.insertFragmentAtRange(selection, fragment)\n  value = change.value\n  document = value.document\n\n  const newTexts = document.getTexts().filter(n => !keys.includes(n.key))\n  const newText = isAppending ? newTexts.last() : newTexts.takeLast(2).first()\n\n  if (newText && lastInline) {\n    change.select(selection.collapseToEndOf(newText))\n  } else if (newText) {\n    change.select(\n      selection.collapseToStartOf(newText).move(lastText.text.length)\n    )\n  } else {\n    change.select(selection.collapseToStart().move(lastText.text.length))\n  }\n}\n\n/**\n * Insert an `inline` at the current selection.\n *\n * @param {Change} change\n * @param {String|Object|Inline} inline\n */\n\nChanges.insertInline = (change, inline) => {\n  inline = Inline.create(inline)\n  const { value } = change\n  const { selection } = value\n  change.insertInlineAtRange(selection, inline)\n\n  // If the node was successfully inserted, update the selection.\n  const node = change.value.document.getNode(inline.key)\n  if (node) change.collapseToEndOf(node)\n}\n\n/**\n * Insert a string of `text` with optional `marks` at the current selection.\n *\n * @param {Change} change\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\nChanges.insertText = (change, text, marks) => {\n  const { value } = change\n  const { document, selection } = value\n  marks = marks || selection.marks || document.getInsertMarksAtRange(selection)\n  change.insertTextAtRange(selection, text, marks)\n\n  // If the text was successfully inserted, and the selection had marks on it,\n  // unset the selection's marks.\n  if (selection.marks && document != change.value.document) {\n    change.select({ marks: null })\n  }\n}\n\n/**\n * Split the block node at the current selection, to optional `depth`.\n *\n * @param {Change} change\n * @param {Number} depth (optional)\n */\n\nChanges.splitBlock = (change, depth = 1) => {\n  const { value } = change\n  const { selection } = value\n  change.splitBlockAtRange(selection, depth).collapseToEnd()\n}\n\n/**\n * Remove a `mark` from the characters in the current selection.\n *\n * @param {Change} change\n * @param {Mark} mark\n */\n\nChanges.removeMark = (change, mark) => {\n  mark = Mark.create(mark)\n  const { value } = change\n  const { document, selection } = value\n\n  if (selection.isExpanded) {\n    change.removeMarkAtRange(selection, mark)\n  } else if (selection.marks) {\n    const marks = selection.marks.remove(mark)\n    const sel = selection.set('marks', marks)\n    change.select(sel)\n  } else {\n    const marks = document.getActiveMarksAtRange(selection).remove(mark)\n    const sel = selection.set('marks', marks)\n    change.select(sel)\n  }\n}\n\n/**\n * Add or remove a `mark` from the characters in the current selection,\n * depending on whether it's already there.\n *\n * @param {Change} change\n * @param {Mark} mark\n */\n\nChanges.toggleMark = (change, mark) => {\n  mark = Mark.create(mark)\n  const { value } = change\n  const exists = value.activeMarks.has(mark)\n\n  if (exists) {\n    change.removeMark(mark)\n  } else {\n    change.addMark(mark)\n  }\n}\n\n/**\n * Wrap the current selection with prefix/suffix.\n *\n * @param {Change} change\n * @param {String} prefix\n * @param {String} suffix\n */\n\nChanges.wrapText = (change, prefix, suffix = prefix) => {\n  const { value } = change\n  const { selection } = value\n  change.wrapTextAtRange(selection, prefix, suffix)\n\n  // If the selection was collapsed, it will have moved the start offset too.\n  if (selection.isCollapsed) {\n    change.moveStart(0 - prefix.length)\n  }\n\n  // Adding the suffix will have pushed the end of the selection further on, so\n  // we need to move it back to account for this.\n  change.moveEnd(0 - suffix.length)\n\n  // There's a chance that the selection points moved \"through\" each other,\n  // resulting in a now-incorrect selection direction.\n  if (selection.isForward != change.value.selection.isForward) {\n    change.flip()\n  }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Changes\n","import { reverse } from 'esrever'\n\n/**\n * Surrogate pair start and end points.\n *\n * @type {Number}\n */\n\nconst SURROGATE_START = 0xd800\nconst SURROGATE_END = 0xdfff\n\n/**\n * A regex to match space characters.\n *\n * @type {RegExp}\n */\n\nconst SPACE = /\\s/\n\n/**\n * A regex to match chameleon characters, that count as word characters as long\n * as they are inside of a word.\n *\n * @type {RegExp}\n */\n\nconst CHAMELEON = /['\\u2018\\u2019]/\n\n/**\n * A regex that matches punctuation.\n *\n * @type {RegExp}\n */\n\nconst PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\n\n/**\n * Is a character `code` in a surrogate character.\n *\n * @param {Number} code\n * @return {Boolean}\n */\n\nfunction isSurrogate(code) {\n  return SURROGATE_START <= code && code <= SURROGATE_END\n}\n\n/**\n * Is a character a word character? Needs the `remaining` characters too.\n *\n * @param {String} char\n * @param {String|Void} remaining\n * @return {Boolean}\n */\n\nfunction isWord(char, remaining) {\n  if (SPACE.test(char)) return false\n\n  // If it's a chameleon character, recurse to see if the next one is or not.\n  if (CHAMELEON.test(char)) {\n    let next = remaining.charAt(0)\n    const length = getCharLength(next)\n    next = remaining.slice(0, length)\n    const rest = remaining.slice(length)\n    if (isWord(next, rest)) return true\n  }\n\n  if (PUNCTUATION.test(char)) return false\n  return true\n}\n\n/**\n * Get the length of a `character`.\n *\n * @param {String} char\n * @return {Number}\n */\n\nfunction getCharLength(char) {\n  return isSurrogate(char.charCodeAt(0)) ? 2 : 1\n}\n\n/**\n * Get the offset to the end of the first character in `text`.\n *\n * @param {String} text\n * @return {Number}\n */\n\nfunction getCharOffset(text) {\n  const char = text.charAt(0)\n  return getCharLength(char)\n}\n\n/**\n * Get the offset to the end of the character before an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getCharOffsetBackward(text, offset) {\n  text = text.slice(0, offset)\n  text = reverse(text)\n  return getCharOffset(text)\n}\n\n/**\n * Get the offset to the end of the character after an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getCharOffsetForward(text, offset) {\n  text = text.slice(offset)\n  return getCharOffset(text)\n}\n\n/**\n * Get the offset to the end of the first word in `text`.\n *\n * @param {String} text\n * @return {Number}\n */\n\nfunction getWordOffset(text) {\n  let length = 0\n  let i = 0\n  let started = false\n  let char\n\n  while ((char = text.charAt(i))) {\n    const l = getCharLength(char)\n    char = text.slice(i, i + l)\n    const rest = text.slice(i + l)\n\n    if (isWord(char, rest)) {\n      started = true\n      length += l\n    } else if (!started) {\n      length += l\n    } else {\n      break\n    }\n\n    i += l\n  }\n\n  return length\n}\n\n/**\n * Get the offset to the end of the word before an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getWordOffsetBackward(text, offset) {\n  text = text.slice(0, offset)\n  text = reverse(text)\n  const o = getWordOffset(text)\n  return o\n}\n\n/**\n * Get the offset to the end of the word after an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getWordOffsetForward(text, offset) {\n  text = text.slice(offset)\n  const o = getWordOffset(text)\n  return o\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  getCharOffsetForward,\n  getCharOffsetBackward,\n  getWordOffsetBackward,\n  getWordOffsetForward,\n}\n","import { List } from 'immutable'\n\nimport Block from '../models/block'\nimport Inline from '../models/inline'\nimport Mark from '../models/mark'\nimport Node from '../models/node'\nimport String from '../utils/string'\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nconst Changes = {}\n\n/**\n * Add a new `mark` to the characters at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Mixed} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.addMarkAtRange = (change, range, mark, options = {}) => {\n  if (range.isCollapsed) return\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset, endKey, endOffset } = range\n  const texts = document.getTextsAtRange(range)\n\n  texts.forEach(node => {\n    const { key } = node\n    let index = 0\n    let length = node.text.length\n\n    if (key == startKey) index = startOffset\n    if (key == endKey) length = endOffset\n    if (key == startKey && key == endKey) length = endOffset - startOffset\n\n    change.addMarkByKey(key, index, length, mark, { normalize })\n  })\n}\n\n/**\n * Add a list of `marks` to the characters at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Array<Mixed>} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.addMarksAtRange = (change, range, marks, options = {}) => {\n  marks.forEach(mark => change.addMarkAtRange(range, mark, options))\n}\n\n/**\n * Delete everything in a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteAtRange = (change, range, options = {}) => {\n  if (range.isCollapsed) return\n\n  // Snapshot the selection, which creates an extra undo save point, so that\n  // when you undo a delete, the expanded selection will be retained.\n  change.snapshotSelection()\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  let { startKey, startOffset, endKey, endOffset } = range\n  let { document } = value\n  let isStartVoid = document.hasVoidParent(startKey)\n  let isEndVoid = document.hasVoidParent(endKey)\n  let startBlock = document.getClosestBlock(startKey)\n  let endBlock = document.getClosestBlock(endKey)\n\n  // Check if we have a \"hanging\" selection case where the even though the\n  // selection extends into the start of the end node, we actually want to\n  // ignore that for UX reasons.\n  const isHanging =\n    startOffset == 0 &&\n    endOffset == 0 &&\n    isStartVoid == false &&\n    startKey == startBlock.getFirstText().key &&\n    endKey == endBlock.getFirstText().key\n\n  // If it's a hanging selection, nudge it back to end in the previous text.\n  if (isHanging && isEndVoid) {\n    const prevText = document.getPreviousText(endKey)\n    endKey = prevText.key\n    endOffset = prevText.text.length\n    isEndVoid = document.hasVoidParent(endKey)\n  }\n\n  // If the start node is inside a void node, remove the void node and update\n  // the starting point to be right after it, continuously until the start point\n  // is not a void, or until the entire range is handled.\n  while (isStartVoid) {\n    const startVoid = document.getClosestVoid(startKey)\n    const nextText = document.getNextText(startKey)\n    change.removeNodeByKey(startVoid.key, { normalize: false })\n\n    // If the start and end keys are the same, we're done.\n    if (startKey == endKey) return\n\n    // If there is no next text node, we're done.\n    if (!nextText) return\n\n    // Continue...\n    document = change.value.document\n    startKey = nextText.key\n    startOffset = 0\n    isStartVoid = document.hasVoidParent(startKey)\n  }\n\n  // If the end node is inside a void node, do the same thing but backwards. But\n  // we don't need any aborting checks because if we've gotten this far there\n  // must be a non-void node that will exit the loop.\n  while (isEndVoid) {\n    const endVoid = document.getClosestVoid(endKey)\n    const prevText = document.getPreviousText(endKey)\n    change.removeNodeByKey(endVoid.key, { normalize: false })\n\n    // Continue...\n    document = change.value.document\n    endKey = prevText.key\n    endOffset = prevText.text.length\n    isEndVoid = document.hasVoidParent(endKey)\n  }\n\n  // If the start and end key are the same, and it was a hanging selection, we\n  // can just remove the entire block.\n  if (startKey == endKey && isHanging) {\n    change.removeNodeByKey(startBlock.key, { normalize })\n    return\n  } else if (startKey == endKey) {\n    // Otherwise, if it wasn't hanging, we're inside a single text node, so we can\n    // simply remove the text in the range.\n    const index = startOffset\n    const length = endOffset - startOffset\n    change.removeTextByKey(startKey, index, length, { normalize })\n    return\n  } else {\n    // Otherwise, we need to recursively remove text and nodes inside the start\n    // block after the start offset and inside the end block before the end\n    // offset. Then remove any blocks that are in between the start and end\n    // blocks. Then finally merge the start and end nodes.\n    startBlock = document.getClosestBlock(startKey)\n    endBlock = document.getClosestBlock(endKey)\n    const startText = document.getNode(startKey)\n    const endText = document.getNode(endKey)\n    const startLength = startText.text.length - startOffset\n    const endLength = endOffset\n\n    const ancestor = document.getCommonAncestor(startKey, endKey)\n    const startChild = ancestor.getFurthestAncestor(startKey)\n    const endChild = ancestor.getFurthestAncestor(endKey)\n\n    const startParent = document.getParent(startBlock.key)\n    const startParentIndex = startParent.nodes.indexOf(startBlock)\n    const endParentIndex = startParent.nodes.indexOf(endBlock)\n\n    let child\n\n    // Iterate through all of the nodes in the tree after the start text node\n    // but inside the end child, and remove them.\n    child = startText\n\n    while (child.key != startChild.key) {\n      const parent = document.getParent(child.key)\n      const index = parent.nodes.indexOf(child)\n      const afters = parent.nodes.slice(index + 1)\n\n      afters.reverse().forEach(node => {\n        change.removeNodeByKey(node.key, { normalize: false })\n      })\n\n      child = parent\n    }\n\n    // Remove all of the middle children.\n    const startChildIndex = ancestor.nodes.indexOf(startChild)\n    const endChildIndex = ancestor.nodes.indexOf(endChild)\n    const middles = ancestor.nodes.slice(startChildIndex + 1, endChildIndex)\n\n    middles.reverse().forEach(node => {\n      change.removeNodeByKey(node.key, { normalize: false })\n    })\n\n    // Remove the nodes before the end text node in the tree.\n    child = endText\n\n    while (child.key != endChild.key) {\n      const parent = document.getParent(child.key)\n      const index = parent.nodes.indexOf(child)\n      const befores = parent.nodes.slice(0, index)\n\n      befores.reverse().forEach(node => {\n        change.removeNodeByKey(node.key, { normalize: false })\n      })\n\n      child = parent\n    }\n\n    // Remove any overlapping text content from the leaf text nodes.\n    if (startLength != 0) {\n      change.removeTextByKey(startKey, startOffset, startLength, {\n        normalize: false,\n      })\n    }\n\n    if (endLength != 0) {\n      change.removeTextByKey(endKey, 0, endOffset, { normalize: false })\n    }\n\n    // If the start and end blocks aren't the same, move and merge the end block\n    // into the start block.\n    if (startBlock.key != endBlock.key) {\n      document = change.value.document\n      const lonely = document.getFurthestOnlyChildAncestor(endBlock.key)\n\n      // Move the end block to be right after the start block.\n      if (endParentIndex != startParentIndex + 1) {\n        change.moveNodeByKey(\n          endBlock.key,\n          startParent.key,\n          startParentIndex + 1,\n          { normalize: false }\n        )\n      }\n\n      // If the selection is hanging, just remove the start block, otherwise\n      // merge the end block into it.\n      if (isHanging) {\n        change.removeNodeByKey(startBlock.key, { normalize: false })\n      } else {\n        change.mergeNodeByKey(endBlock.key, { normalize: false })\n      }\n\n      // If nested empty blocks are left over above the end block, remove them.\n      if (lonely) {\n        change.removeNodeByKey(lonely.key, { normalize: false })\n      }\n    }\n\n    // If we should normalize, do it now after everything.\n    if (normalize) {\n      change.normalizeNodeByKey(ancestor.key)\n    }\n  }\n}\n\n/**\n * Delete backward until the character boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteCharBackwardAtRange = (change, range, options) => {\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset } = range\n  const startBlock = document.getClosestBlock(startKey)\n  const offset = startBlock.getOffset(startKey)\n  const o = offset + startOffset\n  const { text } = startBlock\n  const n = String.getCharOffsetBackward(text, o)\n  change.deleteBackwardAtRange(range, n, options)\n}\n\n/**\n * Delete backward until the line boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteLineBackwardAtRange = (change, range, options) => {\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset } = range\n  const startBlock = document.getClosestBlock(startKey)\n  const offset = startBlock.getOffset(startKey)\n  const startWithVoidInline =\n    startBlock.nodes.size > 1 &&\n    startBlock.nodes.get(0).text == '' &&\n    startBlock.nodes.get(1).object == 'inline'\n\n  let o = offset + startOffset\n\n  // If line starts with an void inline node, the text node inside this inline\n  // node disturbs the offset. Ignore this inline node and delete it afterwards.\n  if (startWithVoidInline) {\n    o -= 1\n  }\n\n  change.deleteBackwardAtRange(range, o, options)\n\n  // Delete the remaining first inline node if needed.\n  if (startWithVoidInline) {\n    change.deleteBackward()\n  }\n}\n\n/**\n * Delete backward until the word boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteWordBackwardAtRange = (change, range, options) => {\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset } = range\n  const startBlock = document.getClosestBlock(startKey)\n  const offset = startBlock.getOffset(startKey)\n  const o = offset + startOffset\n  const { text } = startBlock\n  const n = String.getWordOffsetBackward(text, o)\n  change.deleteBackwardAtRange(range, n, options)\n}\n\n/**\n * Delete backward `n` characters at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Number} n (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteBackwardAtRange = (change, range, n = 1, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const { startKey, focusOffset } = range\n\n  // If the range is expanded, perform a regular delete instead.\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize })\n    return\n  }\n\n  const block = document.getClosestBlock(startKey)\n\n  // If the closest block is void, delete it.\n  if (block && block.isVoid) {\n    change.removeNodeByKey(block.key, { normalize })\n    return\n  }\n\n  // If the closest is not void, but empty, remove it\n  if (block && !block.isVoid && block.isEmpty && document.nodes.size !== 1) {\n    change.removeNodeByKey(block.key, { normalize })\n    return\n  }\n\n  // If the closest inline is void, delete it.\n  const inline = document.getClosestInline(startKey)\n  if (inline && inline.isVoid) {\n    change.removeNodeByKey(inline.key, { normalize })\n    return\n  }\n\n  // If the range is at the start of the document, abort.\n  if (range.isAtStartOf(document)) {\n    return\n  }\n\n  // If the range is at the start of the text node, we need to figure out what\n  // is behind it to know how to delete...\n  const text = document.getDescendant(startKey)\n  if (range.isAtStartOf(text)) {\n    const prev = document.getPreviousText(text.key)\n    const prevBlock = document.getClosestBlock(prev.key)\n    const prevInline = document.getClosestInline(prev.key)\n\n    // If the previous block is void, remove it.\n    if (prevBlock && prevBlock.isVoid) {\n      change.removeNodeByKey(prevBlock.key, { normalize })\n      return\n    }\n\n    // If the previous inline is void, remove it.\n    if (prevInline && prevInline.isVoid) {\n      change.removeNodeByKey(prevInline.key, { normalize })\n      return\n    }\n\n    // If we're deleting by one character and the previous text node is not\n    // inside the current block, we need to merge the two blocks together.\n    if (n == 1 && prevBlock != block) {\n      range = range.merge({\n        anchorKey: prev.key,\n        anchorOffset: prev.text.length,\n      })\n\n      change.deleteAtRange(range, { normalize })\n      return\n    }\n  }\n\n  // If the focus offset is farther than the number of characters to delete,\n  // just remove the characters backwards inside the current node.\n  if (n < focusOffset) {\n    range = range.merge({\n      focusOffset: focusOffset - n,\n      isBackward: true,\n    })\n\n    change.deleteAtRange(range, { normalize })\n    return\n  }\n\n  // Otherwise, we need to see how many nodes backwards to go.\n  let node = text\n  let offset = 0\n  let traversed = focusOffset\n\n  while (n > traversed) {\n    node = document.getPreviousText(node.key)\n    const next = traversed + node.text.length\n    if (n <= next) {\n      offset = next - n\n      break\n    } else {\n      traversed = next\n    }\n  }\n\n  // If the focus node is inside a void, go up until right after it.\n  if (document.hasVoidParent(node.key)) {\n    const parent = document.getClosestVoid(node.key)\n    node = document.getNextText(parent.key)\n    offset = 0\n  }\n\n  range = range.merge({\n    focusKey: node.key,\n    focusOffset: offset,\n    isBackward: true,\n  })\n\n  change.deleteAtRange(range, { normalize })\n}\n\n/**\n * Delete forward until the character boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteCharForwardAtRange = (change, range, options) => {\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset } = range\n  const startBlock = document.getClosestBlock(startKey)\n  const offset = startBlock.getOffset(startKey)\n  const o = offset + startOffset\n  const { text } = startBlock\n  const n = String.getCharOffsetForward(text, o)\n  change.deleteForwardAtRange(range, n, options)\n}\n\n/**\n * Delete forward until the line boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteLineForwardAtRange = (change, range, options) => {\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset } = range\n  const startBlock = document.getClosestBlock(startKey)\n  const offset = startBlock.getOffset(startKey)\n  const o = offset + startOffset\n  change.deleteForwardAtRange(range, o, options)\n}\n\n/**\n * Delete forward until the word boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteWordForwardAtRange = (change, range, options) => {\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset } = range\n  const startBlock = document.getClosestBlock(startKey)\n  const offset = startBlock.getOffset(startKey)\n  const o = offset + startOffset\n  const { text } = startBlock\n  const n = String.getWordOffsetForward(text, o)\n  change.deleteForwardAtRange(range, n, options)\n}\n\n/**\n * Delete forward `n` characters at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Number} n (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteForwardAtRange = (change, range, n = 1, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const { startKey, focusOffset } = range\n\n  // If the range is expanded, perform a regular delete instead.\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize })\n    return\n  }\n\n  const block = document.getClosestBlock(startKey)\n\n  // If the closest block is void, delete it.\n  if (block && block.isVoid) {\n    change.removeNodeByKey(block.key, { normalize })\n    return\n  }\n\n  // If the closest is not void, but empty, remove it\n  if (block && !block.isVoid && block.isEmpty && document.nodes.size !== 1) {\n    const nextBlock = document.getNextBlock(block.key)\n    change.removeNodeByKey(block.key, { normalize })\n    if (nextBlock && nextBlock.key) {\n      change.moveToStartOf(nextBlock)\n    }\n    return\n  }\n\n  // If the closest inline is void, delete it.\n  const inline = document.getClosestInline(startKey)\n  if (inline && inline.isVoid) {\n    change.removeNodeByKey(inline.key, { normalize })\n    return\n  }\n\n  // If the range is at the start of the document, abort.\n  if (range.isAtEndOf(document)) {\n    return\n  }\n\n  // If the range is at the start of the text node, we need to figure out what\n  // is behind it to know how to delete...\n  const text = document.getDescendant(startKey)\n  if (range.isAtEndOf(text)) {\n    const next = document.getNextText(text.key)\n    const nextBlock = document.getClosestBlock(next.key)\n    const nextInline = document.getClosestInline(next.key)\n\n    // If the previous block is void, remove it.\n    if (nextBlock && nextBlock.isVoid) {\n      change.removeNodeByKey(nextBlock.key, { normalize })\n      return\n    }\n\n    // If the previous inline is void, remove it.\n    if (nextInline && nextInline.isVoid) {\n      change.removeNodeByKey(nextInline.key, { normalize })\n      return\n    }\n\n    // If we're deleting by one character and the previous text node is not\n    // inside the current block, we need to merge the two blocks together.\n    if (n == 1 && nextBlock != block) {\n      range = range.merge({\n        focusKey: next.key,\n        focusOffset: 0,\n      })\n\n      change.deleteAtRange(range, { normalize })\n      return\n    }\n  }\n\n  // If the remaining characters to the end of the node is greater than or equal\n  // to the number of characters to delete, just remove the characters forwards\n  // inside the current node.\n  if (n <= text.text.length - focusOffset) {\n    range = range.merge({\n      focusOffset: focusOffset + n,\n    })\n\n    change.deleteAtRange(range, { normalize })\n    return\n  }\n\n  // Otherwise, we need to see how many nodes forwards to go.\n  let node = text\n  let offset = focusOffset\n  let traversed = text.text.length - focusOffset\n\n  while (n > traversed) {\n    node = document.getNextText(node.key)\n    const next = traversed + node.text.length\n    if (n <= next) {\n      offset = n - traversed\n      break\n    } else {\n      traversed = next\n    }\n  }\n\n  // If the focus node is inside a void, go up until right before it.\n  if (document.hasVoidParent(node.key)) {\n    const parent = document.getClosestVoid(node.key)\n    node = document.getPreviousText(parent.key)\n    offset = node.text.length\n  }\n\n  range = range.merge({\n    focusKey: node.key,\n    focusOffset: offset,\n  })\n\n  change.deleteAtRange(range, { normalize })\n}\n\n/**\n * Insert a `block` node at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Block|String|Object} block\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.insertBlockAtRange = (change, range, block, options = {}) => {\n  block = Block.create(block)\n  const normalize = change.getFlag('normalize', options)\n\n  if (range.isExpanded) {\n    change.deleteAtRange(range)\n    range = range.collapseToStart()\n  }\n\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset } = range\n  const startBlock = document.getClosestBlock(startKey)\n  const parent = document.getParent(startBlock.key)\n  const index = parent.nodes.indexOf(startBlock)\n\n  if (startBlock.isVoid) {\n    const extra = range.isAtEndOf(startBlock) ? 1 : 0\n    change.insertNodeByKey(parent.key, index + extra, block, { normalize })\n  } else if (startBlock.isEmpty) {\n    change.insertNodeByKey(parent.key, index + 1, block, { normalize })\n  } else if (range.isAtStartOf(startBlock)) {\n    change.insertNodeByKey(parent.key, index, block, { normalize })\n  } else if (range.isAtEndOf(startBlock)) {\n    change.insertNodeByKey(parent.key, index + 1, block, { normalize })\n  } else {\n    change.splitDescendantsByKey(startBlock.key, startKey, startOffset, {\n      normalize: false,\n    })\n    change.insertNodeByKey(parent.key, index + 1, block, { normalize })\n  }\n\n  if (normalize) {\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Insert a `fragment` at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Document} fragment\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.insertFragmentAtRange = (change, range, fragment, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n\n  // If the range is expanded, delete it first.\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize: false })\n    range = range.collapseToStart()\n  }\n\n  // If the fragment is empty, there's nothing to do after deleting.\n  if (!fragment.nodes.size) return\n\n  // Regenerate the keys for all of the fragments nodes, so that they're\n  // guaranteed not to collide with the existing keys in the document. Otherwise\n  // they will be rengerated automatically and we won't have an easy way to\n  // reference them.\n  fragment = fragment.mapDescendants(child => child.regenerateKey())\n\n  // Calculate a few things...\n  const { startKey, startOffset } = range\n  const { value } = change\n  let { document } = value\n  let startText = document.getDescendant(startKey)\n  let startBlock = document.getClosestBlock(startText.key)\n  let startChild = startBlock.getFurthestAncestor(startText.key)\n  const isAtStart = range.isAtStartOf(startBlock)\n  const parent = document.getParent(startBlock.key)\n  const index = parent.nodes.indexOf(startBlock)\n  const blocks = fragment.getBlocks()\n  const firstBlock = blocks.first()\n  const lastBlock = blocks.last()\n\n  // If the fragment only contains a void block, use `insertBlock` instead.\n  if (firstBlock == lastBlock && firstBlock.isVoid) {\n    change.insertBlockAtRange(range, firstBlock, options)\n    return\n  }\n\n  // If the first and last block aren't the same, we need to insert all of the\n  // nodes after the fragment's first block at the index.\n  if (firstBlock != lastBlock) {\n    const lonelyParent = fragment.getFurthest(\n      firstBlock.key,\n      p => p.nodes.size == 1\n    )\n    const lonelyChild = lonelyParent || firstBlock\n    const startIndex = parent.nodes.indexOf(startBlock)\n    fragment = fragment.removeDescendant(lonelyChild.key)\n\n    fragment.nodes.forEach((node, i) => {\n      const newIndex = startIndex + i + 1\n      change.insertNodeByKey(parent.key, newIndex, node, { normalize: false })\n    })\n  }\n\n  // Check if we need to split the node.\n  if (startOffset != 0) {\n    change.splitDescendantsByKey(startChild.key, startKey, startOffset, {\n      normalize: false,\n    })\n  }\n\n  // Update our variables with the new value.\n  document = change.value.document\n  startText = document.getDescendant(startKey)\n  startBlock = document.getClosestBlock(startKey)\n  startChild = startBlock.getFurthestAncestor(startText.key)\n\n  // If the first and last block aren't the same, we need to move any of the\n  // starting block's children after the split into the last block of the\n  // fragment, which has already been inserted.\n  if (firstBlock != lastBlock) {\n    const nextChild = isAtStart\n      ? startChild\n      : startBlock.getNextSibling(startChild.key)\n    const nextNodes = nextChild\n      ? startBlock.nodes.skipUntil(n => n.key == nextChild.key)\n      : List()\n    const lastIndex = lastBlock.nodes.size\n\n    nextNodes.forEach((node, i) => {\n      const newIndex = lastIndex + i\n      change.moveNodeByKey(node.key, lastBlock.key, newIndex, {\n        normalize: false,\n      })\n    })\n  }\n\n  // If the starting block is empty, we replace it entirely with the first block\n  // of the fragment, since this leads to a more expected behavior for the user.\n  if (startBlock.isEmpty) {\n    change.removeNodeByKey(startBlock.key, { normalize: false })\n    change.insertNodeByKey(parent.key, index, firstBlock, { normalize: false })\n  } else {\n    // Otherwise, we maintain the starting block, and insert all of the first\n    // block's inline nodes into it at the split point.\n    const inlineChild = startBlock.getFurthestAncestor(startText.key)\n    const inlineIndex = startBlock.nodes.indexOf(inlineChild)\n\n    firstBlock.nodes.forEach((inline, i) => {\n      const o = startOffset == 0 ? 0 : 1\n      const newIndex = inlineIndex + i + o\n      change.insertNodeByKey(startBlock.key, newIndex, inline, {\n        normalize: false,\n      })\n    })\n  }\n\n  // Normalize if requested.\n  if (normalize) {\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Insert an `inline` node at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Inline|String|Object} inline\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.insertInlineAtRange = (change, range, inline, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  inline = Inline.create(inline)\n\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize: false })\n    range = range.collapseToStart()\n  }\n\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset } = range\n  const parent = document.getParent(startKey)\n  const startText = document.assertDescendant(startKey)\n  const index = parent.nodes.indexOf(startText)\n\n  if (parent.isVoid) return\n\n  change.splitNodeByKey(startKey, startOffset, { normalize: false })\n  change.insertNodeByKey(parent.key, index + 1, inline, { normalize: false })\n\n  if (normalize) {\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Insert `text` at a `range`, with optional `marks`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.insertTextAtRange = (change, range, text, marks, options = {}) => {\n  let { normalize } = options\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset } = range\n  let key = startKey\n  let offset = startOffset\n  const parent = document.getParent(startKey)\n\n  if (parent.isVoid) return\n\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize: false })\n\n    // Update range start after delete\n    if (change.value.startKey !== key) {\n      key = change.value.startKey\n      offset = change.value.startOffset\n    }\n  }\n\n  // PERF: Unless specified, don't normalize if only inserting text.\n  if (normalize !== undefined) {\n    normalize = range.isExpanded\n  }\n\n  change.insertTextByKey(key, offset, text, marks, { normalize })\n}\n\n/**\n * Remove an existing `mark` to the characters at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Mark|String} mark (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.removeMarkAtRange = (change, range, mark, options = {}) => {\n  if (range.isCollapsed) return\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const texts = document.getTextsAtRange(range)\n  const { startKey, startOffset, endKey, endOffset } = range\n\n  texts.forEach(node => {\n    const { key } = node\n    let index = 0\n    let length = node.text.length\n\n    if (key == startKey) index = startOffset\n    if (key == endKey) length = endOffset\n    if (key == startKey && key == endKey) length = endOffset - startOffset\n\n    change.removeMarkByKey(key, index, length, mark, { normalize })\n  })\n}\n\n/**\n * Set the `properties` of block nodes in a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.setBlockAtRange = (change, range, properties, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const blocks = document.getBlocksAtRange(range)\n\n  const { startKey, startOffset, endKey, endOffset, isCollapsed } = range\n  const isStartVoid = document.hasVoidParent(startKey)\n  const startBlock = document.getClosestBlock(startKey)\n  const endBlock = document.getClosestBlock(endKey)\n\n  // Check if we have a \"hanging\" selection case where the even though the\n  // selection extends into the start of the end node, we actually want to\n  // ignore that for UX reasons.\n  const isHanging =\n    isCollapsed == false &&\n    startOffset == 0 &&\n    endOffset == 0 &&\n    isStartVoid == false &&\n    startKey == startBlock.getFirstText().key &&\n    endKey == endBlock.getFirstText().key\n\n  // If it's a hanging selection, ignore the last block.\n  const sets = isHanging ? blocks.slice(0, -1) : blocks\n\n  sets.forEach(block => {\n    change.setNodeByKey(block.key, properties, { normalize })\n  })\n}\n\n/**\n * Set the `properties` of inline nodes in a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.setInlineAtRange = (change, range, properties, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const inlines = document.getInlinesAtRange(range)\n\n  inlines.forEach(inline => {\n    change.setNodeByKey(inline.key, properties, { normalize })\n  })\n}\n\n/**\n * Split the block nodes at a `range`, to optional `height`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Number} height (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.splitBlockAtRange = (change, range, height = 1, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize })\n    range = range.collapseToStart()\n  }\n\n  const { startKey, startOffset } = range\n  const { value } = change\n  const { document } = value\n  let node = document.assertDescendant(startKey)\n  let parent = document.getClosestBlock(node.key)\n  let h = 0\n\n  while (parent && parent.object == 'block' && h < height) {\n    node = parent\n    parent = document.getClosestBlock(parent.key)\n    h++\n  }\n\n  change.splitDescendantsByKey(node.key, startKey, startOffset, { normalize })\n}\n\n/**\n * Split the inline nodes at a `range`, to optional `height`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Number} height (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.splitInlineAtRange = (\n  change,\n  range,\n  height = Infinity,\n  options = {}\n) => {\n  const normalize = change.getFlag('normalize', options)\n\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize })\n    range = range.collapseToStart()\n  }\n\n  const { startKey, startOffset } = range\n  const { value } = change\n  const { document } = value\n  let node = document.assertDescendant(startKey)\n  let parent = document.getClosestInline(node.key)\n  let h = 0\n\n  while (parent && parent.object == 'inline' && h < height) {\n    node = parent\n    parent = document.getClosestInline(parent.key)\n    h++\n  }\n\n  change.splitDescendantsByKey(node.key, startKey, startOffset, { normalize })\n}\n\n/**\n * Add or remove a `mark` from the characters at `range`, depending on whether\n * it's already there.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Mixed} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.toggleMarkAtRange = (change, range, mark, options = {}) => {\n  if (range.isCollapsed) return\n\n  mark = Mark.create(mark)\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const marks = document.getActiveMarksAtRange(range)\n  const exists = marks.some(m => m.equals(mark))\n\n  if (exists) {\n    change.removeMarkAtRange(range, mark, { normalize })\n  } else {\n    change.addMarkAtRange(range, mark, { normalize })\n  }\n}\n\n/**\n * Unwrap all of the block nodes in a `range` from a block with `properties`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {String|Object} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.unwrapBlockAtRange = (change, range, properties, options = {}) => {\n  properties = Node.createProperties(properties)\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  let { document } = value\n  const blocks = document.getBlocksAtRange(range)\n  const wrappers = blocks\n    .map(block => {\n      return document.getClosest(block.key, parent => {\n        if (parent.object != 'block') return false\n        if (properties.type != null && parent.type != properties.type)\n          return false\n        if (properties.isVoid != null && parent.isVoid != properties.isVoid)\n          return false\n        if (properties.data != null && !parent.data.isSuperset(properties.data))\n          return false\n        return true\n      })\n    })\n    .filter(exists => exists)\n    .toOrderedSet()\n    .toList()\n\n  wrappers.forEach(block => {\n    const first = block.nodes.first()\n    const last = block.nodes.last()\n    const parent = document.getParent(block.key)\n    const index = parent.nodes.indexOf(block)\n\n    const children = block.nodes.filter(child => {\n      return blocks.some(b => child == b || child.hasDescendant(b.key))\n    })\n\n    const firstMatch = children.first()\n    const lastMatch = children.last()\n\n    if (first == firstMatch && last == lastMatch) {\n      block.nodes.forEach((child, i) => {\n        change.moveNodeByKey(child.key, parent.key, index + i, {\n          normalize: false,\n        })\n      })\n\n      change.removeNodeByKey(block.key, { normalize: false })\n    } else if (last == lastMatch) {\n      block.nodes.skipUntil(n => n == firstMatch).forEach((child, i) => {\n        change.moveNodeByKey(child.key, parent.key, index + 1 + i, {\n          normalize: false,\n        })\n      })\n    } else if (first == firstMatch) {\n      block.nodes\n        .takeUntil(n => n == lastMatch)\n        .push(lastMatch)\n        .forEach((child, i) => {\n          change.moveNodeByKey(child.key, parent.key, index + i, {\n            normalize: false,\n          })\n        })\n    } else {\n      const firstText = firstMatch.getFirstText()\n      change.splitDescendantsByKey(block.key, firstText.key, 0, {\n        normalize: false,\n      })\n      document = change.value.document\n\n      children.forEach((child, i) => {\n        if (i == 0) {\n          const extra = child\n          child = document.getNextBlock(child.key)\n          change.removeNodeByKey(extra.key, { normalize: false })\n        }\n\n        change.moveNodeByKey(child.key, parent.key, index + 1 + i, {\n          normalize: false,\n        })\n      })\n    }\n  })\n\n  // TODO: optmize to only normalize the right block\n  if (normalize) {\n    change.normalizeDocument()\n  }\n}\n\n/**\n * Unwrap the inline nodes in a `range` from an inline with `properties`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {String|Object} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.unwrapInlineAtRange = (change, range, properties, options = {}) => {\n  properties = Node.createProperties(properties)\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const texts = document.getTextsAtRange(range)\n  const inlines = texts\n    .map(text => {\n      return document.getClosest(text.key, parent => {\n        if (parent.object != 'inline') return false\n        if (properties.type != null && parent.type != properties.type)\n          return false\n        if (properties.isVoid != null && parent.isVoid != properties.isVoid)\n          return false\n        if (properties.data != null && !parent.data.isSuperset(properties.data))\n          return false\n        return true\n      })\n    })\n    .filter(exists => exists)\n    .toOrderedSet()\n    .toList()\n\n  inlines.forEach(inline => {\n    const parent = change.value.document.getParent(inline.key)\n    const index = parent.nodes.indexOf(inline)\n\n    inline.nodes.forEach((child, i) => {\n      change.moveNodeByKey(child.key, parent.key, index + i, {\n        normalize: false,\n      })\n    })\n  })\n\n  // TODO: optmize to only normalize the right block\n  if (normalize) {\n    change.normalizeDocument()\n  }\n}\n\n/**\n * Wrap all of the blocks in a `range` in a new `block`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Block|Object|String} block\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.wrapBlockAtRange = (change, range, block, options = {}) => {\n  block = Block.create(block)\n  block = block.set('nodes', block.nodes.clear())\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n\n  const blocks = document.getBlocksAtRange(range)\n  const firstblock = blocks.first()\n  const lastblock = blocks.last()\n  let parent, siblings, index\n\n  // If there is only one block in the selection then we know the parent and\n  // siblings.\n  if (blocks.length === 1) {\n    parent = document.getParent(firstblock.key)\n    siblings = blocks\n  } else {\n    // Determine closest shared parent to all blocks in selection.\n    parent = document.getClosest(firstblock.key, p1 => {\n      return !!document.getClosest(lastblock.key, p2 => p1 == p2)\n    })\n  }\n\n  // If no shared parent could be found then the parent is the document.\n  if (parent == null) parent = document\n\n  // Create a list of direct children siblings of parent that fall in the\n  // selection.\n  if (siblings == null) {\n    const indexes = parent.nodes.reduce((ind, node, i) => {\n      if (node == firstblock || node.hasDescendant(firstblock.key)) ind[0] = i\n      if (node == lastblock || node.hasDescendant(lastblock.key)) ind[1] = i\n      return ind\n    }, [])\n\n    index = indexes[0]\n    siblings = parent.nodes.slice(indexes[0], indexes[1] + 1)\n  }\n\n  // Get the index to place the new wrapped node at.\n  if (index == null) {\n    index = parent.nodes.indexOf(siblings.first())\n  }\n\n  // Inject the new block node into the parent.\n  change.insertNodeByKey(parent.key, index, block, { normalize: false })\n\n  // Move the sibling nodes into the new block node.\n  siblings.forEach((node, i) => {\n    change.moveNodeByKey(node.key, block.key, i, { normalize: false })\n  })\n\n  if (normalize) {\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Wrap the text and inlines in a `range` in a new `inline`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Inline|Object|String} inline\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.wrapInlineAtRange = (change, range, inline, options = {}) => {\n  const { value } = change\n  let { document } = value\n  const normalize = change.getFlag('normalize', options)\n  const { startKey, startOffset, endKey, endOffset } = range\n\n  if (range.isCollapsed) {\n    // Wrapping an inline void\n    const inlineParent = document.getClosestInline(startKey)\n    if (!inlineParent.isVoid) {\n      return\n    }\n\n    return change.wrapInlineByKey(inlineParent.key, inline, options)\n  }\n\n  inline = Inline.create(inline)\n  inline = inline.set('nodes', inline.nodes.clear())\n\n  const blocks = document.getBlocksAtRange(range)\n  let startBlock = document.getClosestBlock(startKey)\n  let endBlock = document.getClosestBlock(endKey)\n  let startChild = startBlock.getFurthestAncestor(startKey)\n  let endChild = endBlock.getFurthestAncestor(endKey)\n\n  change.splitDescendantsByKey(endChild.key, endKey, endOffset, {\n    normalize: false,\n  })\n  change.splitDescendantsByKey(startChild.key, startKey, startOffset, {\n    normalize: false,\n  })\n\n  document = change.value.document\n  startBlock = document.getDescendant(startBlock.key)\n  endBlock = document.getDescendant(endBlock.key)\n  startChild = startBlock.getFurthestAncestor(startKey)\n  endChild = endBlock.getFurthestAncestor(endKey)\n  const startIndex = startBlock.nodes.indexOf(startChild)\n  const endIndex = endBlock.nodes.indexOf(endChild)\n\n  if (startBlock == endBlock) {\n    document = change.value.document\n    startBlock = document.getClosestBlock(startKey)\n    startChild = startBlock.getFurthestAncestor(startKey)\n\n    const startInner = document.getNextSibling(startChild.key)\n    const startInnerIndex = startBlock.nodes.indexOf(startInner)\n    const endInner =\n      startKey == endKey ? startInner : startBlock.getFurthestAncestor(endKey)\n    const inlines = startBlock.nodes\n      .skipUntil(n => n == startInner)\n      .takeUntil(n => n == endInner)\n      .push(endInner)\n\n    const node = inline.regenerateKey()\n\n    change.insertNodeByKey(startBlock.key, startInnerIndex, node, {\n      normalize: false,\n    })\n\n    inlines.forEach((child, i) => {\n      change.moveNodeByKey(child.key, node.key, i, { normalize: false })\n    })\n\n    if (normalize) {\n      change.normalizeNodeByKey(startBlock.key)\n    }\n  } else {\n    const startInlines = startBlock.nodes.slice(startIndex + 1)\n    const endInlines = endBlock.nodes.slice(0, endIndex + 1)\n    const startNode = inline.regenerateKey()\n    const endNode = inline.regenerateKey()\n\n    change.insertNodeByKey(startBlock.key, startIndex + 1, startNode, {\n      normalize: false,\n    })\n    change.insertNodeByKey(endBlock.key, endIndex, endNode, {\n      normalize: false,\n    })\n\n    startInlines.forEach((child, i) => {\n      change.moveNodeByKey(child.key, startNode.key, i, { normalize: false })\n    })\n\n    endInlines.forEach((child, i) => {\n      change.moveNodeByKey(child.key, endNode.key, i, { normalize: false })\n    })\n\n    if (normalize) {\n      change.normalizeNodeByKey(startBlock.key).normalizeNodeByKey(endBlock.key)\n    }\n\n    blocks.slice(1, -1).forEach(block => {\n      const node = inline.regenerateKey()\n      change.insertNodeByKey(block.key, 0, node, { normalize: false })\n\n      block.nodes.forEach((child, i) => {\n        change.moveNodeByKey(child.key, node.key, i, { normalize: false })\n      })\n\n      if (normalize) {\n        change.normalizeNodeByKey(block.key)\n      }\n    })\n  }\n}\n\n/**\n * Wrap the text in a `range` in a prefix/suffix.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {String} prefix\n * @param {String} suffix (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.wrapTextAtRange = (\n  change,\n  range,\n  prefix,\n  suffix = prefix,\n  options = {}\n) => {\n  const normalize = change.getFlag('normalize', options)\n  const { startKey, endKey } = range\n  const start = range.collapseToStart()\n  let end = range.collapseToEnd()\n\n  if (startKey == endKey) {\n    end = end.move(prefix.length)\n  }\n\n  change.insertTextAtRange(start, prefix, [], { normalize })\n  change.insertTextAtRange(end, suffix, [], { normalize })\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Changes\n","import Block from '../models/block'\nimport Inline from '../models/inline'\nimport Mark from '../models/mark'\nimport Node from '../models/node'\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nconst Changes = {}\n\n/**\n * Add mark to text at `offset` and `length` in node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {Mixed} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.addMarkByKey = (change, key, offset, length, mark, options = {}) => {\n  mark = Mark.create(mark)\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const path = document.getPath(key)\n  const node = document.getNode(key)\n  const leaves = node.getLeaves()\n\n  const operations = []\n  const bx = offset\n  const by = offset + length\n  let o = 0\n\n  leaves.forEach(leaf => {\n    const ax = o\n    const ay = ax + leaf.text.length\n\n    o += leaf.text.length\n\n    // If the leaf doesn't overlap with the operation, continue on.\n    if (ay < bx || by < ax) return\n\n    // If the leaf already has the mark, continue on.\n    if (leaf.marks.has(mark)) return\n\n    // Otherwise, determine which offset and characters overlap.\n    const start = Math.max(ax, bx)\n    const end = Math.min(ay, by)\n\n    operations.push({\n      type: 'add_mark',\n      value,\n      path,\n      offset: start,\n      length: end - start,\n      mark,\n    })\n  })\n\n  change.applyOperations(operations)\n\n  if (normalize) {\n    const parent = document.getParent(key)\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Insert a `fragment` at `index` in a node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} index\n * @param {Fragment} fragment\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.insertFragmentByKey = (change, key, index, fragment, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n\n  fragment.nodes.forEach((node, i) => {\n    change.insertNodeByKey(key, index + i, node)\n  })\n\n  if (normalize) {\n    change.normalizeNodeByKey(key)\n  }\n}\n\n/**\n * Insert a `node` at `index` in a node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} index\n * @param {Node} node\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.insertNodeByKey = (change, key, index, node, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const path = document.getPath(key)\n\n  change.applyOperation({\n    type: 'insert_node',\n    value,\n    path: [...path, index],\n    node,\n  })\n\n  if (normalize) {\n    change.normalizeNodeByKey(key)\n  }\n}\n\n/**\n * Insert `text` at `offset` in node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} offset\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.insertTextByKey = (change, key, offset, text, marks, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n\n  const { value } = change\n  const { document } = value\n  const path = document.getPath(key)\n  const node = document.getNode(key)\n  marks = marks || node.getMarksAtIndex(offset)\n\n  change.applyOperation({\n    type: 'insert_text',\n    value,\n    path,\n    offset,\n    text,\n    marks,\n  })\n\n  if (normalize) {\n    const parent = document.getParent(key)\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Merge a node by `key` with the previous node.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.mergeNodeByKey = (change, key, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const path = document.getPath(key)\n  const original = document.getDescendant(key)\n  const previous = document.getPreviousSibling(key)\n\n  if (!previous) {\n    throw new Error(`Unable to merge node with key \"${key}\", no previous key.`)\n  }\n\n  const position =\n    previous.object == 'text' ? previous.text.length : previous.nodes.size\n\n  change.applyOperation({\n    type: 'merge_node',\n    value,\n    path,\n    position,\n    // for undos to succeed we only need the type and data because\n    // these are the only properties that get changed in the merge operation\n    properties: {\n      type: original.type,\n      data: original.data,\n    },\n    target: null,\n  })\n\n  if (normalize) {\n    const parent = document.getParent(key)\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Move a node by `key` to a new parent by `newKey` and `index`.\n * `newKey` is the key of the container (it can be the document itself)\n *\n * @param {Change} change\n * @param {String} key\n * @param {String} newKey\n * @param {Number} index\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.moveNodeByKey = (change, key, newKey, newIndex, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const path = document.getPath(key)\n  const newPath = document.getPath(newKey)\n\n  change.applyOperation({\n    type: 'move_node',\n    value,\n    path,\n    newPath: [...newPath, newIndex],\n  })\n\n  if (normalize) {\n    const parent = document.getCommonAncestor(key, newKey)\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Remove mark from text at `offset` and `length` in node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {Mark} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.removeMarkByKey = (change, key, offset, length, mark, options = {}) => {\n  mark = Mark.create(mark)\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const path = document.getPath(key)\n  const node = document.getNode(key)\n  const leaves = node.getLeaves()\n\n  const operations = []\n  const bx = offset\n  const by = offset + length\n  let o = 0\n\n  leaves.forEach(leaf => {\n    const ax = o\n    const ay = ax + leaf.text.length\n\n    o += leaf.text.length\n\n    // If the leaf doesn't overlap with the operation, continue on.\n    if (ay < bx || by < ax) return\n\n    // If the leaf already has the mark, continue on.\n    if (!leaf.marks.has(mark)) return\n\n    // Otherwise, determine which offset and characters overlap.\n    const start = Math.max(ax, bx)\n    const end = Math.min(ay, by)\n\n    operations.push({\n      type: 'remove_mark',\n      value,\n      path,\n      offset: start,\n      length: end - start,\n      mark,\n    })\n  })\n\n  change.applyOperations(operations)\n\n  if (normalize) {\n    const parent = document.getParent(key)\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Remove all `marks` from node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.removeAllMarksByKey = (change, key, options = {}) => {\n  const { state } = change\n  const { document } = state\n  const node = document.getNode(key)\n  const texts = node.object === 'text' ? [node] : node.getTextsAsArray()\n\n  texts.forEach(text => {\n    text.getMarksAsArray().forEach(mark => {\n      change.removeMarkByKey(text.key, 0, text.text.length, mark, options)\n    })\n  })\n}\n\n/**\n * Remove a node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.removeNodeByKey = (change, key, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const path = document.getPath(key)\n  const node = document.getNode(key)\n\n  change.applyOperation({\n    type: 'remove_node',\n    value,\n    path,\n    node,\n  })\n\n  if (normalize) {\n    const parent = document.getParent(key)\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Remove text at `offset` and `length` in node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.removeTextByKey = (change, key, offset, length, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const path = document.getPath(key)\n  const node = document.getNode(key)\n  const leaves = node.getLeaves()\n  const { text } = node\n\n  const removals = []\n  const bx = offset\n  const by = offset + length\n  let o = 0\n\n  leaves.forEach(leaf => {\n    const ax = o\n    const ay = ax + leaf.text.length\n\n    o += leaf.text.length\n\n    // If the leaf doesn't overlap with the removal, continue on.\n    if (ay < bx || by < ax) return\n\n    // Otherwise, determine which offset and characters overlap.\n    const start = Math.max(ax, bx)\n    const end = Math.min(ay, by)\n    const string = text.slice(start, end)\n\n    removals.push({\n      type: 'remove_text',\n      value,\n      path,\n      offset: start,\n      text: string,\n      marks: leaf.marks,\n    })\n  })\n\n  // Apply in reverse order, so subsequent removals don't impact previous ones.\n  change.applyOperations(removals.reverse())\n\n  if (normalize) {\n    const block = document.getClosestBlock(key)\n    change.normalizeNodeByKey(block.key)\n  }\n}\n\n/**\n`* Replace a `node` with another `node`\n *\n * @param {Change} change\n * @param {String} key\n * @param {Object|Node} node\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.replaceNodeByKey = (change, key, newNode, options = {}) => {\n  newNode = Node.create(newNode)\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const node = document.getNode(key)\n  const parent = document.getParent(key)\n  const index = parent.nodes.indexOf(node)\n  change.removeNodeByKey(key, { normalize: false })\n  change.insertNodeByKey(parent.key, index, newNode, options)\n  if (normalize) {\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Set `properties` on mark on text at `offset` and `length` in node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {Mark} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.setMarkByKey = (\n  change,\n  key,\n  offset,\n  length,\n  mark,\n  properties,\n  options = {}\n) => {\n  mark = Mark.create(mark)\n  properties = Mark.createProperties(properties)\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const path = document.getPath(key)\n\n  change.applyOperation({\n    type: 'set_mark',\n    value,\n    path,\n    offset,\n    length,\n    mark,\n    properties,\n  })\n\n  if (normalize) {\n    const parent = document.getParent(key)\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Set `properties` on a node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.setNodeByKey = (change, key, properties, options = {}) => {\n  properties = Node.createProperties(properties)\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const path = document.getPath(key)\n  const node = document.getNode(key)\n\n  change.applyOperation({\n    type: 'set_node',\n    value,\n    path,\n    node,\n    properties,\n  })\n\n  if (normalize) {\n    change.normalizeNodeByKey(node.key)\n  }\n}\n\n/**\n * Split a node by `key` at `position`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} position\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.splitNodeByKey = (change, key, position, options = {}) => {\n  const { normalize = true, target = null } = options\n  const { value } = change\n  const { document } = value\n  const path = document.getPath(key)\n  const node = document.getDescendantAtPath(path)\n\n  change.applyOperation({\n    type: 'split_node',\n    value,\n    path,\n    position,\n    properties: {\n      type: node.type,\n      data: node.data,\n    },\n    target,\n  })\n\n  if (normalize) {\n    const parent = document.getParent(key)\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Split a node deeply down the tree by `key`, `textKey` and `textOffset`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} position\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.splitDescendantsByKey = (\n  change,\n  key,\n  textKey,\n  textOffset,\n  options = {}\n) => {\n  if (key == textKey) {\n    change.splitNodeByKey(textKey, textOffset, options)\n    return\n  }\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n\n  const text = document.getNode(textKey)\n  const ancestors = document.getAncestors(textKey)\n  const nodes = ancestors\n    .skipUntil(a => a.key == key)\n    .reverse()\n    .unshift(text)\n  let previous\n  let index\n\n  nodes.forEach(node => {\n    const prevIndex = index == null ? null : index\n    index = previous ? node.nodes.indexOf(previous) + 1 : textOffset\n    previous = node\n    change.splitNodeByKey(node.key, index, {\n      normalize: false,\n      target: prevIndex,\n    })\n  })\n\n  if (normalize) {\n    const parent = document.getParent(key)\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Unwrap content from an inline parent with `properties`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.unwrapInlineByKey = (change, key, properties, options) => {\n  const { value } = change\n  const { document, selection } = value\n  const node = document.assertDescendant(key)\n  const first = node.getFirstText()\n  const last = node.getLastText()\n  const range = selection.moveToRangeOf(first, last)\n  change.unwrapInlineAtRange(range, properties, options)\n}\n\n/**\n * Unwrap content from a block parent with `properties`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.unwrapBlockByKey = (change, key, properties, options) => {\n  const { value } = change\n  const { document, selection } = value\n  const node = document.assertDescendant(key)\n  const first = node.getFirstText()\n  const last = node.getLastText()\n  const range = selection.moveToRangeOf(first, last)\n  change.unwrapBlockAtRange(range, properties, options)\n}\n\n/**\n * Unwrap a single node from its parent.\n *\n * If the node is surrounded with siblings, its parent will be\n * split. If the node is the only child, the parent is removed, and\n * simply replaced by the node itself.  Cannot unwrap a root node.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.unwrapNodeByKey = (change, key, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const parent = document.getParent(key)\n  const node = parent.getChild(key)\n\n  const index = parent.nodes.indexOf(node)\n  const isFirst = index === 0\n  const isLast = index === parent.nodes.size - 1\n\n  const parentParent = document.getParent(parent.key)\n  const parentIndex = parentParent.nodes.indexOf(parent)\n\n  if (parent.nodes.size === 1) {\n    change.moveNodeByKey(key, parentParent.key, parentIndex, {\n      normalize: false,\n    })\n    change.removeNodeByKey(parent.key, options)\n  } else if (isFirst) {\n    // Just move the node before its parent.\n    change.moveNodeByKey(key, parentParent.key, parentIndex, options)\n  } else if (isLast) {\n    // Just move the node after its parent.\n    change.moveNodeByKey(key, parentParent.key, parentIndex + 1, options)\n  } else {\n    // Split the parent.\n    change.splitNodeByKey(parent.key, index, { normalize: false })\n\n    // Extract the node in between the splitted parent.\n    change.moveNodeByKey(key, parentParent.key, parentIndex + 1, {\n      normalize: false,\n    })\n\n    if (normalize) {\n      change.normalizeNodeByKey(parentParent.key)\n    }\n  }\n}\n\n/**\n * Wrap a node in a block with `properties`.\n *\n * @param {Change} change\n * @param {String} key The node to wrap\n * @param {Block|Object|String} block The wrapping block (its children are discarded)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.wrapBlockByKey = (change, key, block, options) => {\n  block = Block.create(block)\n  block = block.set('nodes', block.nodes.clear())\n\n  const { document } = change.value\n  const node = document.assertDescendant(key)\n  const parent = document.getParent(node.key)\n  const index = parent.nodes.indexOf(node)\n\n  change.insertNodeByKey(parent.key, index, block, { normalize: false })\n  change.moveNodeByKey(node.key, block.key, 0, options)\n}\n\n/**\n * Wrap a node in an inline with `properties`.\n *\n * @param {Change} change\n * @param {String} key The node to wrap\n * @param {Block|Object|String} inline The wrapping inline (its children are discarded)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.wrapInlineByKey = (change, key, inline, options) => {\n  inline = Inline.create(inline)\n  inline = inline.set('nodes', inline.nodes.clear())\n\n  const { document } = change.value\n  const node = document.assertDescendant(key)\n  const parent = document.getParent(node.key)\n  const index = parent.nodes.indexOf(node)\n\n  change.insertNodeByKey(parent.key, index, inline, { normalize: false })\n  change.moveNodeByKey(node.key, inline.key, 0, options)\n}\n\n/**\n * Wrap a node by `key` with `parent`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Node|Object} parent\n * @param {Object} options\n */\n\nChanges.wrapNodeByKey = (change, key, parent) => {\n  parent = Node.create(parent)\n  parent = parent.set('nodes', parent.nodes.clear())\n\n  if (parent.object == 'block') {\n    change.wrapBlockByKey(key, parent)\n    return\n  }\n\n  if (parent.object == 'inline') {\n    change.wrapInlineByKey(key, parent)\n    return\n  }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Changes\n","/**\n * Slate operation attributes.\n *\n * @type {Array}\n */\n\nconst OPERATION_ATTRIBUTES = {\n  add_mark: ['value', 'path', 'offset', 'length', 'mark'],\n  insert_node: ['value', 'path', 'node'],\n  insert_text: ['value', 'path', 'offset', 'text', 'marks'],\n  merge_node: ['value', 'path', 'position', 'properties', 'target'],\n  move_node: ['value', 'path', 'newPath'],\n  remove_mark: ['value', 'path', 'offset', 'length', 'mark'],\n  remove_node: ['value', 'path', 'node'],\n  remove_text: ['value', 'path', 'offset', 'text', 'marks'],\n  set_mark: ['value', 'path', 'offset', 'length', 'mark', 'properties'],\n  set_node: ['value', 'path', 'node', 'properties'],\n  set_selection: ['value', 'selection', 'properties'],\n  set_value: ['value', 'properties'],\n  split_node: ['value', 'path', 'position', 'properties', 'target'],\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default OPERATION_ATTRIBUTES\n","import Debug from 'debug'\nimport isEqual from 'lodash/isEqual'\nimport isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { List, Record, Stack } from 'immutable'\n\nimport MODEL_TYPES from '../constants/model-types'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:history')\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  redos: new Stack(),\n  undos: new Stack(),\n}\n\n/**\n * History.\n *\n * @type {History}\n */\n\nclass History extends Record(DEFAULTS) {\n  /**\n   * Create a new `History` with `attrs`.\n   *\n   * @param {Object|History} attrs\n   * @return {History}\n   */\n\n  static create(attrs = {}) {\n    if (History.isHistory(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return History.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`History.create\\` only accepts objects or histories, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `History` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {History}\n   */\n\n  static fromJSON(object) {\n    const { redos = [], undos = [] } = object\n\n    const history = new History({\n      redos: new Stack(redos),\n      undos: new Stack(undos),\n    })\n\n    return history\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = History.fromJSON\n\n  /**\n   * Check if `any` is a `History`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isHistory(any) {\n    return !!(any && any[MODEL_TYPES.HISTORY])\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'history'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Save an `operation` into the history.\n   *\n   * @param {Object} operation\n   * @param {Object} options\n   * @return {History}\n   */\n\n  save(operation, options = {}) {\n    let history = this\n    let { undos, redos } = history\n    let { merge, skip } = options\n    const prevBatch = undos.peek()\n    const prevOperation = prevBatch && prevBatch.last()\n\n    if (skip == null) {\n      skip = shouldSkip(operation, prevOperation)\n    }\n\n    if (skip) {\n      return history\n    }\n\n    if (merge == null) {\n      merge = shouldMerge(operation, prevOperation)\n    }\n\n    debug('save', { operation, merge })\n\n    // If the `merge` flag is true, add the operation to the previous batch.\n    if (merge && prevBatch) {\n      const batch = prevBatch.push(operation)\n      undos = undos.pop()\n      undos = undos.push(batch)\n    } else {\n      // Otherwise, create a new batch with the operation.\n      const batch = new List([operation])\n      undos = undos.push(batch)\n    }\n\n    // Constrain the history to 100 entries for memory's sake.\n    if (undos.size > 100) {\n      undos = undos.take(100)\n    }\n\n    // Clear the redos and update the history.\n    redos = redos.clear()\n    history = history.set('undos', undos).set('redos', redos)\n    return history\n  }\n\n  /**\n   * Return a JSON representation of the history.\n   *\n   * @return {Object}\n   */\n\n  toJSON() {\n    const object = {\n      object: this.object,\n      redos: this.redos.toJSON(),\n      undos: this.undos.toJSON(),\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS() {\n    return this.toJSON()\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nHistory.prototype[MODEL_TYPES.HISTORY] = true\n\n/**\n * Check whether to merge a new operation `o` into the previous operation `p`.\n *\n * @param {Object} o\n * @param {Object} p\n * @return {Boolean}\n */\n\nfunction shouldMerge(o, p) {\n  if (!p) return false\n\n  const merge =\n    (o.type == 'set_selection' && p.type == 'set_selection') ||\n    (o.type == 'insert_text' &&\n      p.type == 'insert_text' &&\n      o.offset == p.offset + p.text.length &&\n      isEqual(o.path, p.path)) ||\n    (o.type == 'remove_text' &&\n      p.type == 'remove_text' &&\n      o.offset + o.text.length == p.offset &&\n      isEqual(o.path, p.path))\n\n  return merge\n}\n\n/**\n * Check whether to skip a new operation `o`, given previous operation `p`.\n *\n * @param {Object} o\n * @param {Object} p\n * @return {Boolean}\n */\n\nfunction shouldSkip(o, p) {\n  if (!p) return false\n\n  const skip = o.type == 'set_selection' && p.type == 'set_selection'\n\n  return skip\n}\n\n/**\n * Export.\n *\n * @type {History}\n */\n\nexport default History\n","import { List } from 'immutable'\n\nimport Text from '../models/text'\n\n/**\n * Define the core schema rules, order-sensitive.\n *\n * @type {Array}\n */\n\nconst CORE_SCHEMA_RULES = [\n  /**\n   * Only allow block nodes in documents.\n   *\n   * @type {Object}\n   */\n\n  {\n    validateNode(node) {\n      if (node.object != 'document') return\n      const invalids = node.nodes.filter(n => n.object != 'block')\n      if (!invalids.size) return\n\n      return change => {\n        invalids.forEach(child => {\n          change.removeNodeByKey(child.key, { normalize: false })\n        })\n      }\n    },\n  },\n\n  /**\n   * Only allow block nodes or inline and text nodes in blocks.\n   *\n   * @type {Object}\n   */\n\n  {\n    validateNode(node) {\n      if (node.object != 'block') return\n      const first = node.nodes.first()\n      if (!first) return\n      const objects = first.object == 'block' ? ['block'] : ['inline', 'text']\n      const invalids = node.nodes.filter(n => !objects.includes(n.object))\n      if (!invalids.size) return\n\n      return change => {\n        invalids.forEach(child => {\n          change.removeNodeByKey(child.key, { normalize: false })\n        })\n      }\n    },\n  },\n\n  /**\n   * Only allow inline and text nodes in inlines.\n   *\n   * @type {Object}\n   */\n\n  {\n    validateNode(node) {\n      if (node.object != 'inline') return\n      const invalids = node.nodes.filter(\n        n => n.object != 'inline' && n.object != 'text'\n      )\n      if (!invalids.size) return\n\n      return change => {\n        invalids.forEach(child => {\n          change.removeNodeByKey(child.key, { normalize: false })\n        })\n      }\n    },\n  },\n\n  /**\n   * Ensure that block and inline nodes have at least one text child.\n   *\n   * @type {Object}\n   */\n\n  {\n    validateNode(node) {\n      if (node.object != 'block' && node.object != 'inline') return\n      if (node.nodes.size > 0) return\n\n      return change => {\n        const text = Text.create()\n        change.insertNodeByKey(node.key, 0, text, { normalize: false })\n      }\n    },\n  },\n\n  /**\n   * Ensure that void nodes contain a text node with a single space of text.\n   *\n   * @type {Object}\n   */\n\n  {\n    validateNode(node) {\n      if (!node.isVoid) return\n      if (node.object != 'block' && node.object != 'inline') return\n      if (node.text == ' ' && node.nodes.size == 1) return\n\n      return change => {\n        const text = Text.create(' ')\n        const index = node.nodes.size\n\n        change.insertNodeByKey(node.key, index, text, { normalize: false })\n\n        node.nodes.forEach(child => {\n          change.removeNodeByKey(child.key, { normalize: false })\n        })\n      }\n    },\n  },\n\n  /**\n   * Ensure that inline nodes are never empty.\n   *\n   * This rule is applied to all blocks, because when they contain an empty\n   * inline, we need to remove the inline from that parent block. If `validate`\n   * was to be memoized, it should be against the parent node, not the inline\n   * themselves.\n   *\n   * @type {Object}\n   */\n\n  {\n    validateNode(node) {\n      if (node.object != 'block') return\n      const invalids = node.nodes.filter(\n        n => n.object == 'inline' && n.text == ''\n      )\n      if (!invalids.size) return\n\n      return change => {\n        // If all of the block's nodes are invalid, insert an empty text node so\n        // that the selection will be preserved when they are all removed.\n        if (node.nodes.size == invalids.size) {\n          const text = Text.create()\n          change.insertNodeByKey(node.key, 1, text, { normalize: false })\n        }\n\n        invalids.forEach(child => {\n          change.removeNodeByKey(child.key, { normalize: false })\n        })\n      }\n    },\n  },\n\n  /**\n   * Ensure that inline void nodes are surrounded by text nodes, by adding extra\n   * blank text nodes if necessary.\n   *\n   * @type {Object}\n   */\n\n  {\n    validateNode(node) {\n      if (node.object != 'block' && node.object != 'inline') return\n\n      const invalids = node.nodes.reduce((list, child, index) => {\n        if (child.object !== 'inline') return list\n\n        const prev = index > 0 ? node.nodes.get(index - 1) : null\n        const next = node.nodes.get(index + 1)\n        // We don't test if \"prev\" is inline, since it has already been processed in the loop\n        const insertBefore = !prev\n        const insertAfter = !next || next.object == 'inline'\n\n        if (insertAfter || insertBefore) {\n          list = list.push({ insertAfter, insertBefore, index })\n        }\n\n        return list\n      }, new List())\n\n      if (!invalids.size) return\n\n      return change => {\n        // Shift for every text node inserted previously.\n        let shift = 0\n\n        invalids.forEach(({ index, insertAfter, insertBefore }) => {\n          if (insertBefore) {\n            change.insertNodeByKey(node.key, shift + index, Text.create(), {\n              normalize: false,\n            })\n            shift++\n          }\n\n          if (insertAfter) {\n            change.insertNodeByKey(node.key, shift + index + 1, Text.create(), {\n              normalize: false,\n            })\n            shift++\n          }\n        })\n      }\n    },\n  },\n\n  /**\n   * Merge adjacent text nodes.\n   *\n   * @type {Object}\n   */\n\n  {\n    validateNode(node) {\n      if (node.object != 'block' && node.object != 'inline') return\n\n      const invalids = node.nodes\n        .map((child, i) => {\n          const next = node.nodes.get(i + 1)\n          if (child.object != 'text') return\n          if (!next || next.object != 'text') return\n          return next\n        })\n        .filter(Boolean)\n\n      if (!invalids.size) return\n\n      return change => {\n        // Reverse the list to handle consecutive merges, since the earlier nodes\n        // will always exist after each merge.\n        invalids.reverse().forEach(n => {\n          change.mergeNodeByKey(n.key, { normalize: false })\n        })\n      }\n    },\n  },\n\n  /**\n   * Prevent extra empty text nodes, except when adjacent to inline void nodes.\n   *\n   * @type {Object}\n   */\n\n  {\n    validateNode(node) {\n      if (node.object != 'block' && node.object != 'inline') return\n      const { nodes } = node\n      if (nodes.size <= 1) return\n\n      const invalids = nodes.filter((desc, i) => {\n        if (desc.object != 'text') return\n        if (desc.text.length > 0) return\n\n        const prev = i > 0 ? nodes.get(i - 1) : null\n        const next = nodes.get(i + 1)\n\n        // If it's the first node, and the next is a void, preserve it.\n        if (!prev && next.object == 'inline') return\n\n        // It it's the last node, and the previous is an inline, preserve it.\n        if (!next && prev.object == 'inline') return\n\n        // If it's surrounded by inlines, preserve it.\n        if (next && prev && next.object == 'inline' && prev.object == 'inline')\n          return\n\n        // Otherwise, remove it.\n        return true\n      })\n\n      if (!invalids.size) return\n\n      return change => {\n        invalids.forEach(text => {\n          change.removeNodeByKey(text.key, { normalize: false })\n        })\n      }\n    },\n  },\n]\n\n/**\n * Export.\n *\n * @type {Array}\n */\n\nexport default CORE_SCHEMA_RULES\n","import logger from 'slate-dev-logger'\nimport { Record } from 'immutable'\n\nimport MODEL_TYPES from '../constants/model-types'\nimport memoize from '../utils/memoize'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  plugins: [],\n}\n\n/**\n * Stack.\n *\n * @type {Stack}\n */\n\nclass Stack extends Record(DEFAULTS) {\n  /**\n   * Constructor.\n   *\n   * @param {Object} attrs\n   */\n\n  static create(attrs = {}) {\n    const { plugins = [] } = attrs\n    const stack = new Stack({ plugins })\n    return stack\n  }\n\n  /**\n   * Check if `any` is a `Stack`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isStack(any) {\n    return !!(any && any[MODEL_TYPES.STACK])\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'stack'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Get all plugins with `property`.\n   *\n   * @param {String} property\n   * @return {Array}\n   */\n\n  getPluginsWith(property) {\n    return this.plugins.filter(plugin => plugin[property] != null)\n  }\n\n  /**\n   * Iterate the plugins with `property`, returning the first non-null value.\n   *\n   * @param {String} property\n   * @param {Any} ...args\n   */\n\n  find(property, ...args) {\n    const plugins = this.getPluginsWith(property)\n\n    for (const plugin of plugins) {\n      const ret = plugin[property](...args)\n      if (ret != null) return ret\n    }\n  }\n\n  /**\n   * Iterate the plugins with `property`, returning all the non-null values.\n   *\n   * @param {String} property\n   * @param {Any} ...args\n   * @return {Array}\n   */\n\n  map(property, ...args) {\n    const plugins = this.getPluginsWith(property)\n    const array = []\n\n    for (const plugin of plugins) {\n      const ret = plugin[property](...args)\n      if (ret != null) array.push(ret)\n    }\n\n    return array\n  }\n\n  /**\n   * Iterate the plugins with `property`, breaking on any a non-null values.\n   *\n   * @param {String} property\n   * @param {Any} ...args\n   */\n\n  run(property, ...args) {\n    const plugins = this.getPluginsWith(property)\n\n    for (const plugin of plugins) {\n      const ret = plugin[property](...args)\n      if (ret != null) return\n    }\n  }\n\n  /**\n   * Iterate the plugins with `property`, reducing to a set of React children.\n   *\n   * @param {String} property\n   * @param {Object} props\n   * @param {Any} ...args\n   */\n\n  render(property, props, ...args) {\n    const plugins = this.getPluginsWith(property)\n      .slice()\n      .reverse()\n    let { children = null } = props\n\n    for (const plugin of plugins) {\n      const ret = plugin[property](props, ...args)\n      if (ret == null) continue\n      props.children = children = ret\n    }\n\n    return children\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nStack.prototype[MODEL_TYPES.STACK] = true\n\n/**\n * Memoize read methods.\n */\n\nmemoize(Stack.prototype, ['getPluginsWith'], {\n  takesArguments: true,\n})\n\n/**\n * Export.\n *\n * @type {Stack}\n */\n\nexport default Stack\n","import Debug from 'debug'\nimport isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport mergeWith from 'lodash/mergeWith'\nimport { Record } from 'immutable'\n\nimport {\n  CHILD_OBJECT_INVALID,\n  CHILD_REQUIRED,\n  CHILD_TYPE_INVALID,\n  CHILD_UNKNOWN,\n  FIRST_CHILD_OBJECT_INVALID,\n  FIRST_CHILD_TYPE_INVALID,\n  LAST_CHILD_OBJECT_INVALID,\n  LAST_CHILD_TYPE_INVALID,\n  NODE_DATA_INVALID,\n  NODE_IS_VOID_INVALID,\n  NODE_MARK_INVALID,\n  NODE_TEXT_INVALID,\n  PARENT_OBJECT_INVALID,\n  PARENT_TYPE_INVALID,\n} from 'slate-schema-violations'\n\nimport CORE_SCHEMA_RULES from '../constants/core-schema-rules'\nimport MODEL_TYPES from '../constants/model-types'\nimport Stack from './stack'\nimport memoize from '../utils/memoize'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:schema')\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  stack: Stack.create(),\n  document: {},\n  blocks: {},\n  inlines: {},\n}\n\n/**\n * Schema.\n *\n * @type {Schema}\n */\n\nclass Schema extends Record(DEFAULTS) {\n  /**\n   * Create a new `Schema` with `attrs`.\n   *\n   * @param {Object|Schema} attrs\n   * @return {Schema}\n   */\n\n  static create(attrs = {}) {\n    if (Schema.isSchema(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Schema.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Schema.create\\` only accepts objects or schemas, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Schema` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Schema}\n   */\n\n  static fromJSON(object) {\n    if (Schema.isSchema(object)) {\n      return object\n    }\n\n    let { plugins } = object\n\n    if (object.rules) {\n      throw new Error(\n        'Schemas in Slate have changed! They are no longer accept a `rules` property.'\n      )\n    }\n\n    if (object.nodes) {\n      throw new Error(\n        'Schemas in Slate have changed! They are no longer accept a `nodes` property.'\n      )\n    }\n\n    if (!plugins) {\n      plugins = [{ schema: object }]\n    }\n\n    const schema = resolveSchema(plugins)\n    const stack = Stack.create({ plugins: [...CORE_SCHEMA_RULES, ...plugins] })\n    const ret = new Schema({ ...schema, stack })\n    return ret\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Schema.fromJSON\n\n  /**\n   * Check if `any` is a `Schema`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isSchema(any) {\n    return !!(any && any[MODEL_TYPES.SCHEMA])\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'schema'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Get the rule for an `object`.\n   *\n   * @param {Mixed} object\n   * @return {Object}\n   */\n\n  getRule(object) {\n    switch (object.object) {\n      case 'document':\n        return this.document\n      case 'block':\n        return this.blocks[object.type]\n      case 'inline':\n        return this.inlines[object.type]\n    }\n  }\n\n  /**\n   * Get a dictionary of the parent rule validations by child type.\n   *\n   * @return {Object|Null}\n   */\n\n  getParentRules() {\n    const { blocks, inlines } = this\n    const parents = {}\n\n    for (const key in blocks) {\n      const rule = blocks[key]\n      if (rule.parent == null) continue\n      parents[key] = rule\n    }\n\n    for (const key in inlines) {\n      const rule = inlines[key]\n      if (rule.parent == null) continue\n      parents[key] = rule\n    }\n\n    return Object.keys(parents).length == 0 ? null : parents\n  }\n\n  /**\n   * Fail validation by returning a normalizing change function.\n   *\n   * @param {String} violation\n   * @param {Object} context\n   * @return {Function}\n   */\n\n  fail(violation, context) {\n    return change => {\n      debug(`normalizing`, { violation, context })\n      const { rule } = context\n      const { size } = change.operations\n      if (rule.normalize) rule.normalize(change, violation, context)\n      if (change.operations.size > size) return\n      this.normalize(change, violation, context)\n    }\n  }\n\n  /**\n   * Normalize an invalid value with `violation` and `context`.\n   *\n   * @param {Change} change\n   * @param {String} violation\n   * @param {Mixed} context\n   */\n\n  normalize(change, violation, context) {\n    switch (violation) {\n      case CHILD_OBJECT_INVALID:\n      case CHILD_TYPE_INVALID:\n      case CHILD_UNKNOWN:\n      case FIRST_CHILD_OBJECT_INVALID:\n      case FIRST_CHILD_TYPE_INVALID:\n      case LAST_CHILD_OBJECT_INVALID:\n      case LAST_CHILD_TYPE_INVALID: {\n        const { child, node } = context\n        return child.object == 'text' &&\n          node.object == 'block' &&\n          node.nodes.size == 1\n          ? change.removeNodeByKey(node.key)\n          : change.removeNodeByKey(child.key)\n      }\n\n      case CHILD_REQUIRED:\n      case NODE_TEXT_INVALID:\n      case PARENT_OBJECT_INVALID:\n      case PARENT_TYPE_INVALID: {\n        const { node } = context\n        return node.object == 'document'\n          ? node.nodes.forEach(child => change.removeNodeByKey(child.key))\n          : change.removeNodeByKey(node.key)\n      }\n\n      case NODE_DATA_INVALID: {\n        const { node, key } = context\n        return node.data.get(key) === undefined && node.object != 'document'\n          ? change.removeNodeByKey(node.key)\n          : change.setNodeByKey(node.key, { data: node.data.delete(key) })\n      }\n\n      case NODE_IS_VOID_INVALID: {\n        const { node } = context\n        return change.setNodeByKey(node.key, { isVoid: !node.isVoid })\n      }\n\n      case NODE_MARK_INVALID: {\n        const { node, mark } = context\n        return node\n          .getTexts()\n          .forEach(t => change.removeMarkByKey(t.key, 0, t.text.length, mark))\n      }\n    }\n  }\n\n  /**\n   * Validate a `node` with the schema, returning a function that will fix the\n   * invalid node, or void if the node is valid.\n   *\n   * @param {Node} node\n   * @return {Function|Void}\n   */\n\n  validateNode(node) {\n    const ret = this.stack.find('validateNode', node)\n    if (ret) return ret\n\n    if (node.object == 'text') return\n\n    const rule = this.getRule(node) || {}\n    const parents = this.getParentRules()\n    const ctx = { node, rule }\n\n    if (rule.isVoid != null) {\n      if (node.isVoid != rule.isVoid) {\n        return this.fail(NODE_IS_VOID_INVALID, ctx)\n      }\n    }\n\n    if (rule.data != null) {\n      for (const key in rule.data) {\n        const fn = rule.data[key]\n        const value = node.data.get(key)\n\n        if (!fn(value)) {\n          return this.fail(NODE_DATA_INVALID, { ...ctx, key, value })\n        }\n      }\n    }\n\n    if (rule.marks != null) {\n      const marks = node.getMarks().toArray()\n\n      for (const mark of marks) {\n        if (!rule.marks.some(def => def.type === mark.type)) {\n          return this.fail(NODE_MARK_INVALID, { ...ctx, mark })\n        }\n      }\n    }\n\n    if (rule.text != null) {\n      const { text } = node\n\n      if (!rule.text.test(text)) {\n        return this.fail(NODE_TEXT_INVALID, { ...ctx, text })\n      }\n    }\n\n    if (rule.first != null) {\n      const { objects, types } = rule.first\n      const child = node.nodes.first()\n\n      if (child && objects && !objects.includes(child.object)) {\n        return this.fail(FIRST_CHILD_OBJECT_INVALID, { ...ctx, child })\n      }\n\n      if (child && types && !types.includes(child.type)) {\n        return this.fail(FIRST_CHILD_TYPE_INVALID, { ...ctx, child })\n      }\n    }\n\n    if (rule.last != null) {\n      const { objects, types } = rule.last\n      const child = node.nodes.last()\n\n      if (child && objects && !objects.includes(child.object)) {\n        return this.fail(LAST_CHILD_OBJECT_INVALID, { ...ctx, child })\n      }\n\n      if (child && types && !types.includes(child.type)) {\n        return this.fail(LAST_CHILD_TYPE_INVALID, { ...ctx, child })\n      }\n    }\n\n    if (rule.nodes != null || parents != null) {\n      const children = node.nodes.toArray()\n      const defs = rule.nodes != null ? rule.nodes.slice() : []\n\n      let offset\n      let min\n      let index\n      let def\n      let max\n      let child\n\n      function nextDef() {\n        offset = offset == null ? null : 0\n        def = defs.shift()\n        min = def && (def.min == null ? 0 : def.min)\n        max = def && (def.max == null ? Infinity : def.max)\n        return !!def\n      }\n\n      function nextChild() {\n        index = index == null ? 0 : index + 1\n        offset = offset == null ? 0 : offset + 1\n        child = children[index]\n        if (max != null && offset == max) nextDef()\n        return !!child\n      }\n      function rewind() {\n        offset -= 1\n        index -= 1\n      }\n\n      if (rule.nodes != null) {\n        nextDef()\n      }\n\n      while (nextChild()) {\n        if (\n          parents != null &&\n          child.object != 'text' &&\n          child.type in parents\n        ) {\n          const r = parents[child.type]\n\n          if (\n            r.parent.objects != null &&\n            !r.parent.objects.includes(node.object)\n          ) {\n            return this.fail(PARENT_OBJECT_INVALID, {\n              node: child,\n              parent: node,\n              rule: r,\n            })\n          }\n\n          if (r.parent.types != null && !r.parent.types.includes(node.type)) {\n            return this.fail(PARENT_TYPE_INVALID, {\n              node: child,\n              parent: node,\n              rule: r,\n            })\n          }\n        }\n\n        if (rule.nodes != null) {\n          if (!def) {\n            return this.fail(CHILD_UNKNOWN, { ...ctx, child, index })\n          }\n\n          if (def.objects != null && !def.objects.includes(child.object)) {\n            if (offset >= min && nextDef()) {\n              rewind()\n              continue\n            }\n            return this.fail(CHILD_OBJECT_INVALID, { ...ctx, child, index })\n          }\n\n          if (def.types != null && !def.types.includes(child.type)) {\n            if (offset >= min && nextDef()) {\n              rewind()\n              continue\n            }\n            return this.fail(CHILD_TYPE_INVALID, { ...ctx, child, index })\n          }\n        }\n      }\n\n      if (rule.nodes != null) {\n        while (min != null) {\n          if (offset < min) {\n            return this.fail(CHILD_REQUIRED, { ...ctx, index })\n          }\n\n          nextDef()\n        }\n      }\n    }\n  }\n\n  /**\n   * Return a JSON representation of the schema.\n   *\n   * @return {Object}\n   */\n\n  toJSON() {\n    const object = {\n      object: this.object,\n      document: this.document,\n      blocks: this.blocks,\n      inlines: this.inlines,\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS() {\n    return this.toJSON()\n  }\n}\n\n/**\n * Resolve a set of schema rules from an array of `plugins`.\n *\n * @param {Array} plugins\n * @return {Object}\n */\n\nfunction resolveSchema(plugins = []) {\n  const schema = {\n    document: {},\n    blocks: {},\n    inlines: {},\n  }\n\n  plugins\n    .slice()\n    .reverse()\n    .forEach(plugin => {\n      if (!plugin.schema) return\n\n      if (plugin.schema.rules) {\n        throw new Error(\n          'Schemas in Slate have changed! They are no longer accept a `rules` property.'\n        )\n      }\n\n      if (plugin.schema.nodes) {\n        throw new Error(\n          'Schemas in Slate have changed! They are no longer accept a `nodes` property.'\n        )\n      }\n\n      const { document = {}, blocks = {}, inlines = {} } = plugin.schema\n      const d = resolveDocumentRule(document)\n      const bs = {}\n      const is = {}\n\n      for (const key in blocks) {\n        bs[key] = resolveNodeRule('block', key, blocks[key])\n      }\n\n      for (const key in inlines) {\n        is[key] = resolveNodeRule('inline', key, inlines[key])\n      }\n\n      mergeWith(schema.document, d, customizer)\n      mergeWith(schema.blocks, bs, customizer)\n      mergeWith(schema.inlines, is, customizer)\n    })\n\n  return schema\n}\n\n/**\n * Resolve a document rule `obj`.\n *\n * @param {Object} obj\n * @return {Object}\n */\n\nfunction resolveDocumentRule(obj) {\n  return {\n    data: {},\n    nodes: null,\n    ...obj,\n  }\n}\n\n/**\n * Resolve a node rule with `type` from `obj`.\n *\n * @param {String} object\n * @param {String} type\n * @param {Object} obj\n * @return {Object}\n */\n\nfunction resolveNodeRule(object, type, obj) {\n  return {\n    data: {},\n    isVoid: null,\n    nodes: null,\n    first: null,\n    last: null,\n    parent: null,\n    text: null,\n    ...obj,\n  }\n}\n\n/**\n * A Lodash customizer for merging schema definitions. Special cases `objects`\n * and `types` arrays to be unioned, and ignores new `null` values.\n *\n * @param {Mixed} target\n * @param {Mixed} source\n * @return {Array|Void}\n */\n\nfunction customizer(target, source, key) {\n  if (key == 'objects' || key == 'types') {\n    return target == null ? source : target.concat(source)\n  } else {\n    return source == null ? target : source\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nSchema.prototype[MODEL_TYPES.SCHEMA] = true\n\n/**\n * Memoize read methods.\n */\n\nmemoize(Schema.prototype, ['getParentRules'], {\n  takesArguments: true,\n})\n\n/**\n * Export.\n *\n * @type {Schema}\n */\n\nexport default Schema\n","import isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { Record, Set, List, Map } from 'immutable'\n\nimport MODEL_TYPES from '../constants/model-types'\nimport Change from './change'\nimport Data from './data'\nimport Document from './document'\nimport History from './history'\nimport Range from './range'\nimport Schema from './schema'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: new Map(),\n  decorations: null,\n  document: Document.create(),\n  history: History.create(),\n  schema: Schema.create(),\n  selection: Range.create(),\n}\n\n/**\n * Value.\n *\n * @type {Value}\n */\n\nclass Value extends Record(DEFAULTS) {\n  /**\n   * Create a new `Value` with `attrs`.\n   *\n   * @param {Object|Value} attrs\n   * @param {Object} options\n   * @return {Value}\n   */\n\n  static create(attrs = {}, options = {}) {\n    if (Value.isValue(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Value.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Value.create\\` only accepts objects or values, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable value properties from `attrs`.\n   *\n   * @param {Object|Value} attrs\n   * @return {Object}\n   */\n\n  static createProperties(attrs = {}) {\n    if (Value.isValue(attrs)) {\n      return {\n        data: attrs.data,\n        decorations: attrs.decorations,\n        schema: attrs.schema,\n      }\n    }\n\n    if (isPlainObject(attrs)) {\n      const props = {}\n      if ('data' in attrs) props.data = Data.create(attrs.data)\n      if ('decorations' in attrs)\n        props.decorations = Range.createList(attrs.decorations)\n      if ('schema' in attrs) props.schema = Schema.create(attrs.schema)\n      return props\n    }\n\n    throw new Error(\n      `\\`Value.createProperties\\` only accepts objects or values, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Value` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @param {Object} options\n   *   @property {Boolean} normalize\n   *   @property {Array} plugins\n   * @return {Value}\n   */\n\n  static fromJSON(object, options = {}) {\n    let { document = {}, selection = {}, schema = {} } = object\n\n    let data = new Map()\n\n    document = Document.fromJSON(document)\n    selection = Range.fromJSON(selection)\n    schema = Schema.fromJSON(schema)\n\n    // Allow plugins to set a default value for `data`.\n    if (options.plugins) {\n      for (const plugin of options.plugins) {\n        if (plugin.data) data = data.merge(plugin.data)\n      }\n    }\n\n    // Then merge in the `data` provided.\n    if ('data' in object) {\n      data = data.merge(object.data)\n    }\n\n    if (selection.isUnset) {\n      const text = document.getFirstText()\n      if (text) selection = selection.collapseToStartOf(text)\n    }\n\n    let value = new Value({\n      data,\n      document,\n      selection,\n      schema,\n    })\n\n    if (options.normalize !== false) {\n      value = value.change({ save: false }).normalize().value\n    }\n\n    return value\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Value.fromJSON\n\n  /**\n   * Check if a `value` is a `Value`.\n   *\n   * @param {Any} value\n   * @return {Boolean}\n   */\n\n  static isValue(value) {\n    return !!(value && value[MODEL_TYPES.VALUE])\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'value'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Are there undoable events?\n   *\n   * @return {Boolean}\n   */\n\n  get hasUndos() {\n    return this.history.undos.size > 0\n  }\n\n  /**\n   * Are there redoable events?\n   *\n   * @return {Boolean}\n   */\n\n  get hasRedos() {\n    return this.history.redos.size > 0\n  }\n\n  /**\n   * Is the current selection blurred?\n   *\n   * @return {Boolean}\n   */\n\n  get isBlurred() {\n    return this.selection.isBlurred\n  }\n\n  /**\n   * Is the current selection focused?\n   *\n   * @return {Boolean}\n   */\n\n  get isFocused() {\n    return this.selection.isFocused\n  }\n\n  /**\n   * Is the current selection collapsed?\n   *\n   * @return {Boolean}\n   */\n\n  get isCollapsed() {\n    return this.selection.isCollapsed\n  }\n\n  /**\n   * Is the current selection expanded?\n   *\n   * @return {Boolean}\n   */\n\n  get isExpanded() {\n    return this.selection.isExpanded\n  }\n\n  /**\n   * Is the current selection backward?\n   *\n   * @return {Boolean} isBackward\n   */\n\n  get isBackward() {\n    return this.selection.isBackward\n  }\n\n  /**\n   * Is the current selection forward?\n   *\n   * @return {Boolean}\n   */\n\n  get isForward() {\n    return this.selection.isForward\n  }\n\n  /**\n   * Get the current start key.\n   *\n   * @return {String}\n   */\n\n  get startKey() {\n    return this.selection.startKey\n  }\n\n  /**\n   * Get the current end key.\n   *\n   * @return {String}\n   */\n\n  get endKey() {\n    return this.selection.endKey\n  }\n\n  /**\n   * Get the current start offset.\n   *\n   * @return {String}\n   */\n\n  get startOffset() {\n    return this.selection.startOffset\n  }\n\n  /**\n   * Get the current end offset.\n   *\n   * @return {String}\n   */\n\n  get endOffset() {\n    return this.selection.endOffset\n  }\n\n  /**\n   * Get the current anchor key.\n   *\n   * @return {String}\n   */\n\n  get anchorKey() {\n    return this.selection.anchorKey\n  }\n\n  /**\n   * Get the current focus key.\n   *\n   * @return {String}\n   */\n\n  get focusKey() {\n    return this.selection.focusKey\n  }\n\n  /**\n   * Get the current anchor offset.\n   *\n   * @return {String}\n   */\n\n  get anchorOffset() {\n    return this.selection.anchorOffset\n  }\n\n  /**\n   * Get the current focus offset.\n   *\n   * @return {String}\n   */\n\n  get focusOffset() {\n    return this.selection.focusOffset\n  }\n\n  /**\n   * Get the current start text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get startBlock() {\n    return this.startKey && this.document.getClosestBlock(this.startKey)\n  }\n\n  /**\n   * Get the current end text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get endBlock() {\n    return this.endKey && this.document.getClosestBlock(this.endKey)\n  }\n\n  /**\n   * Get the current anchor text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get anchorBlock() {\n    return this.anchorKey && this.document.getClosestBlock(this.anchorKey)\n  }\n\n  /**\n   * Get the current focus text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get focusBlock() {\n    return this.focusKey && this.document.getClosestBlock(this.focusKey)\n  }\n\n  /**\n   * Get the current start text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get startInline() {\n    return this.startKey && this.document.getClosestInline(this.startKey)\n  }\n\n  /**\n   * Get the current end text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get endInline() {\n    return this.endKey && this.document.getClosestInline(this.endKey)\n  }\n\n  /**\n   * Get the current anchor text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get anchorInline() {\n    return this.anchorKey && this.document.getClosestInline(this.anchorKey)\n  }\n\n  /**\n   * Get the current focus text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get focusInline() {\n    return this.focusKey && this.document.getClosestInline(this.focusKey)\n  }\n\n  /**\n   * Get the current start text node.\n   *\n   * @return {Text}\n   */\n\n  get startText() {\n    return this.startKey && this.document.getDescendant(this.startKey)\n  }\n\n  /**\n   * Get the current end node.\n   *\n   * @return {Text}\n   */\n\n  get endText() {\n    return this.endKey && this.document.getDescendant(this.endKey)\n  }\n\n  /**\n   * Get the current anchor node.\n   *\n   * @return {Text}\n   */\n\n  get anchorText() {\n    return this.anchorKey && this.document.getDescendant(this.anchorKey)\n  }\n\n  /**\n   * Get the current focus node.\n   *\n   * @return {Text}\n   */\n\n  get focusText() {\n    return this.focusKey && this.document.getDescendant(this.focusKey)\n  }\n\n  /**\n   * Get the next block node.\n   *\n   * @return {Block}\n   */\n\n  get nextBlock() {\n    return this.endKey && this.document.getNextBlock(this.endKey)\n  }\n\n  /**\n   * Get the previous block node.\n   *\n   * @return {Block}\n   */\n\n  get previousBlock() {\n    return this.startKey && this.document.getPreviousBlock(this.startKey)\n  }\n\n  /**\n   * Get the next inline node.\n   *\n   * @return {Inline}\n   */\n\n  get nextInline() {\n    return this.endKey && this.document.getNextInline(this.endKey)\n  }\n\n  /**\n   * Get the previous inline node.\n   *\n   * @return {Inline}\n   */\n\n  get previousInline() {\n    return this.startKey && this.document.getPreviousInline(this.startKey)\n  }\n\n  /**\n   * Get the next text node.\n   *\n   * @return {Text}\n   */\n\n  get nextText() {\n    return this.endKey && this.document.getNextText(this.endKey)\n  }\n\n  /**\n   * Get the previous text node.\n   *\n   * @return {Text}\n   */\n\n  get previousText() {\n    return this.startKey && this.document.getPreviousText(this.startKey)\n  }\n\n  /**\n   * Get the characters in the current selection.\n   *\n   * @return {List<Character>}\n   */\n\n  get characters() {\n    return this.selection.isUnset\n      ? new List()\n      : this.document.getCharactersAtRange(this.selection)\n  }\n\n  /**\n   * Get the marks of the current selection.\n   *\n   * @return {Set<Mark>}\n   */\n\n  get marks() {\n    return this.selection.isUnset\n      ? new Set()\n      : this.selection.marks || this.document.getMarksAtRange(this.selection)\n  }\n\n  /**\n   * Get the active marks of the current selection.\n   *\n   * @return {Set<Mark>}\n   */\n\n  get activeMarks() {\n    return this.selection.isUnset\n      ? new Set()\n      : this.selection.marks ||\n          this.document.getActiveMarksAtRange(this.selection)\n  }\n\n  /**\n   * Get the block nodes in the current selection.\n   *\n   * @return {List<Block>}\n   */\n\n  get blocks() {\n    return this.selection.isUnset\n      ? new List()\n      : this.document.getBlocksAtRange(this.selection)\n  }\n\n  /**\n   * Get the fragment of the current selection.\n   *\n   * @return {Document}\n   */\n\n  get fragment() {\n    return this.selection.isUnset\n      ? Document.create()\n      : this.document.getFragmentAtRange(this.selection)\n  }\n\n  /**\n   * Get the inline nodes in the current selection.\n   *\n   * @return {List<Inline>}\n   */\n\n  get inlines() {\n    return this.selection.isUnset\n      ? new List()\n      : this.document.getInlinesAtRange(this.selection)\n  }\n\n  /**\n   * Get the text nodes in the current selection.\n   *\n   * @return {List<Text>}\n   */\n\n  get texts() {\n    return this.selection.isUnset\n      ? new List()\n      : this.document.getTextsAtRange(this.selection)\n  }\n\n  /**\n   * Check whether the selection is empty.\n   *\n   * @return {Boolean}\n   */\n\n  get isEmpty() {\n    if (this.isCollapsed) return true\n    if (this.endOffset != 0 && this.startOffset != 0) return false\n    return this.fragment.text.length == 0\n  }\n\n  /**\n   * Check whether the selection is collapsed in a void node.\n   *\n   * @return {Boolean}\n   */\n\n  get isInVoid() {\n    if (this.isExpanded) return false\n    return this.document.hasVoidParent(this.startKey)\n  }\n\n  /**\n   * Create a new `Change` with the current value as a starting point.\n   *\n   * @param {Object} attrs\n   * @return {Change}\n   */\n\n  change(attrs = {}) {\n    return new Change({ ...attrs, value: this })\n  }\n\n  /**\n   * Return a JSON representation of the value.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      document: this.document.toJSON(options),\n    }\n\n    if (options.preserveData) {\n      object.data = this.data.toJSON()\n    }\n\n    if (options.preserveDecorations) {\n      object.decorations = this.decorations\n        ? this.decorations.toArray().map(d => d.toJSON())\n        : null\n    }\n\n    if (options.preserveHistory) {\n      object.history = this.history.toJSON()\n    }\n\n    if (options.preserveSelection) {\n      object.selection = this.selection.toJSON()\n    }\n\n    if (options.preserveSchema) {\n      object.schema = this.schema.toJSON()\n    }\n\n    if (options.preserveSelection && !options.preserveKeys) {\n      const { document, selection } = this\n      object.selection.anchorPath = selection.isSet\n        ? document.getPath(selection.anchorKey)\n        : null\n      object.selection.focusPath = selection.isSet\n        ? document.getPath(selection.focusKey)\n        : null\n      delete object.selection.anchorKey\n      delete object.selection.focusKey\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS(options) {\n    return this.toJSON(options)\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nValue.prototype[MODEL_TYPES.VALUE] = true\n\n/**\n * Export.\n */\n\nexport default Value\n","import isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { List, Record } from 'immutable'\n\nimport MODEL_TYPES from '../constants/model-types'\nimport OPERATION_ATTRIBUTES from '../constants/operation-attributes'\nimport Mark from './mark'\nimport Node from './node'\nimport Range from './range'\nimport Value from './value'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  length: undefined,\n  mark: undefined,\n  marks: undefined,\n  newPath: undefined,\n  node: undefined,\n  offset: undefined,\n  path: undefined,\n  position: undefined,\n  properties: undefined,\n  selection: undefined,\n  target: undefined,\n  text: undefined,\n  type: undefined,\n  value: undefined,\n}\n\n/**\n * Operation.\n *\n * @type {Operation}\n */\n\nclass Operation extends Record(DEFAULTS) {\n  /**\n   * Create a new `Operation` with `attrs`.\n   *\n   * @param {Object|Array|List|String|Operation} attrs\n   * @return {Operation}\n   */\n\n  static create(attrs = {}) {\n    if (Operation.isOperation(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Operation.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Operation.create\\` only accepts objects or operations, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Operations` from `elements`.\n   *\n   * @param {Array<Operation|Object>|List<Operation|Object>} elements\n   * @return {List<Operation>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Operation.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Operation.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a `Operation` from a JSON `object`.\n   *\n   * @param {Object|Operation} object\n   * @return {Operation}\n   */\n\n  static fromJSON(object) {\n    if (Operation.isOperation(object)) {\n      return object\n    }\n\n    const { type, value } = object\n    const ATTRIBUTES = OPERATION_ATTRIBUTES[type]\n    const attrs = { type }\n\n    if (!ATTRIBUTES) {\n      throw new Error(\n        `\\`Operation.fromJSON\\` was passed an unrecognized operation type: \"${type}\"`\n      )\n    }\n\n    for (const key of ATTRIBUTES) {\n      let v = object[key]\n\n      if (v === undefined) {\n        // Skip keys for objects that should not be serialized, and are only used\n        // for providing the local-only invert behavior for the history stack.\n        if (key == 'document') continue\n        if (key == 'selection') continue\n        if (key == 'value') continue\n        if (key == 'node' && type != 'insert_node') continue\n\n        throw new Error(\n          `\\`Operation.fromJSON\\` was passed a \"${type}\" operation without the required \"${key}\" attribute.`\n        )\n      }\n\n      if (key == 'mark') {\n        v = Mark.create(v)\n      }\n\n      if (key == 'marks' && v != null) {\n        v = Mark.createSet(v)\n      }\n\n      if (key == 'node') {\n        v = Node.create(v)\n      }\n\n      if (key == 'selection') {\n        v = Range.create(v)\n      }\n\n      if (key == 'value') {\n        v = Value.create(v)\n      }\n\n      if (key == 'properties' && type == 'merge_node') {\n        v = Node.createProperties(v)\n      }\n\n      if (key == 'properties' && type == 'set_mark') {\n        v = Mark.createProperties(v)\n      }\n\n      if (key == 'properties' && type == 'set_node') {\n        v = Node.createProperties(v)\n      }\n\n      if (key == 'properties' && type == 'set_selection') {\n        const { anchorKey, focusKey, ...rest } = v\n        v = Range.createProperties(rest)\n\n        if (anchorKey !== undefined) {\n          v.anchorPath =\n            anchorKey === null ? null : value.document.getPath(anchorKey)\n        }\n\n        if (focusKey !== undefined) {\n          v.focusPath =\n            focusKey === null ? null : value.document.getPath(focusKey)\n        }\n      }\n\n      if (key == 'properties' && type == 'set_value') {\n        v = Value.createProperties(v)\n      }\n\n      if (key == 'properties' && type == 'split_node') {\n        v = Node.createProperties(v)\n      }\n\n      attrs[key] = v\n    }\n\n    const node = new Operation(attrs)\n    return node\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Operation.fromJSON\n\n  /**\n   * Check if `any` is a `Operation`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isOperation(any) {\n    return !!(any && any[MODEL_TYPES.OPERATION])\n  }\n\n  /**\n   * Check if `any` is a list of operations.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isOperationList(any) {\n    return List.isList(any) && any.every(item => Operation.isOperation(item))\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'operation'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Return a JSON representation of the operation.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const { object, type } = this\n    const json = { object, type }\n    const ATTRIBUTES = OPERATION_ATTRIBUTES[type]\n\n    for (const key of ATTRIBUTES) {\n      let value = this[key]\n\n      // Skip keys for objects that should not be serialized, and are only used\n      // for providing the local-only invert behavior for the history stack.\n      if (key == 'document') continue\n      if (key == 'selection') continue\n      if (key == 'value') continue\n      if (key == 'node' && type != 'insert_node') continue\n\n      if (key == 'mark' || key == 'marks' || key == 'node') {\n        value = value.toJSON()\n      }\n\n      if (key == 'properties' && type == 'merge_node') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      if (key == 'properties' && type == 'set_mark') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      if (key == 'properties' && type == 'set_node') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('isVoid' in value) v.isVoid = value.isVoid\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      if (key == 'properties' && type == 'set_selection') {\n        const v = {}\n        if ('anchorOffset' in value) v.anchorOffset = value.anchorOffset\n        if ('anchorPath' in value) v.anchorPath = value.anchorPath\n        if ('focusOffset' in value) v.focusOffset = value.focusOffset\n        if ('focusPath' in value) v.focusPath = value.focusPath\n        if ('isBackward' in value) v.isBackward = value.isBackward\n        if ('isFocused' in value) v.isFocused = value.isFocused\n        if ('marks' in value)\n          v.marks = value.marks == null ? null : value.marks.toJSON()\n        value = v\n      }\n\n      if (key == 'properties' && type == 'set_value') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('decorations' in value) v.decorations = value.decorations.toJS()\n        if ('schema' in value) v.schema = value.schema.toJS()\n        value = v\n      }\n\n      if (key == 'properties' && type == 'split_node') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      json[key] = value\n    }\n\n    return json\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS(options) {\n    return this.toJSON(options)\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nOperation.prototype[MODEL_TYPES.OPERATION] = true\n\n/**\n * Export.\n *\n * @type {Operation}\n */\n\nexport default Operation\n","import Debug from 'debug'\nimport pick from 'lodash/pick'\n\nimport Operation from '../models/operation'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:operation:invert')\n\n/**\n * Invert an `op`.\n *\n * @param {Object} op\n * @return {Object}\n */\n\nfunction invertOperation(op) {\n  op = Operation.create(op)\n  const { type } = op\n  debug(type, op)\n\n  /**\n   * Insert node.\n   */\n\n  if (type == 'insert_node') {\n    const inverse = op.set('type', 'remove_node')\n    return inverse\n  }\n\n  /**\n   * Remove node.\n   */\n\n  if (type == 'remove_node') {\n    const inverse = op.set('type', 'insert_node')\n    return inverse\n  }\n\n  /**\n   * Move node.\n   */\n\n  if (type == 'move_node') {\n    const { newPath, path } = op\n    let inversePath = newPath\n    let inverseNewPath = path\n\n    const pathLast = path.length - 1\n    const newPathLast = newPath.length - 1\n\n    // If the node's old position was a left sibling of an ancestor of\n    // its new position, we need to adjust part of the path by -1.\n    if (\n      path.length < inversePath.length &&\n      path.slice(0, pathLast).every((e, i) => e == inversePath[i]) &&\n      path[pathLast] < inversePath[pathLast]\n    ) {\n      inversePath = inversePath\n        .slice(0, pathLast)\n        .concat([inversePath[pathLast] - 1])\n        .concat(inversePath.slice(pathLast + 1, inversePath.length))\n    }\n\n    // If the node's new position is an ancestor of the old position,\n    // or a left sibling of an ancestor of its old position, we need\n    // to adjust part of the path by 1.\n    if (\n      newPath.length < inverseNewPath.length &&\n      newPath.slice(0, newPathLast).every((e, i) => e == inverseNewPath[i]) &&\n      newPath[newPathLast] <= inverseNewPath[newPathLast]\n    ) {\n      inverseNewPath = inverseNewPath\n        .slice(0, newPathLast)\n        .concat([inverseNewPath[newPathLast] + 1])\n        .concat(inverseNewPath.slice(newPathLast + 1, inverseNewPath.length))\n    }\n\n    const inverse = op.set('path', inversePath).set('newPath', inverseNewPath)\n    return inverse\n  }\n\n  /**\n   * Merge node.\n   */\n\n  if (type == 'merge_node') {\n    const { path } = op\n    const { length } = path\n    const last = length - 1\n    const inversePath = path.slice(0, last).concat([path[last] - 1])\n    const inverse = op.set('type', 'split_node').set('path', inversePath)\n    return inverse\n  }\n\n  /**\n   * Split node.\n   */\n\n  if (type == 'split_node') {\n    const { path } = op\n    const { length } = path\n    const last = length - 1\n    const inversePath = path.slice(0, last).concat([path[last] + 1])\n    const inverse = op.set('type', 'merge_node').set('path', inversePath)\n    return inverse\n  }\n\n  /**\n   * Set node.\n   */\n\n  if (type == 'set_node') {\n    const { properties, node } = op\n    const inverseNode = node.merge(properties)\n    const inverseProperties = pick(node, Object.keys(properties))\n    const inverse = op\n      .set('node', inverseNode)\n      .set('properties', inverseProperties)\n    return inverse\n  }\n\n  /**\n   * Insert text.\n   */\n\n  if (type == 'insert_text') {\n    const inverse = op.set('type', 'remove_text')\n    return inverse\n  }\n\n  /**\n   * Remove text.\n   */\n\n  if (type == 'remove_text') {\n    const inverse = op.set('type', 'insert_text')\n    return inverse\n  }\n\n  /**\n   * Add mark.\n   */\n\n  if (type == 'add_mark') {\n    const inverse = op.set('type', 'remove_mark')\n    return inverse\n  }\n\n  /**\n   * Remove mark.\n   */\n\n  if (type == 'remove_mark') {\n    const inverse = op.set('type', 'add_mark')\n    return inverse\n  }\n\n  /**\n   * Set mark.\n   */\n\n  if (type == 'set_mark') {\n    const { properties, mark } = op\n    const inverseMark = mark.merge(properties)\n    const inverseProperties = pick(mark, Object.keys(properties))\n    const inverse = op\n      .set('mark', inverseMark)\n      .set('properties', inverseProperties)\n    return inverse\n  }\n\n  /**\n   * Set selection.\n   */\n\n  if (type == 'set_selection') {\n    const { properties, selection, value } = op\n    const { anchorPath, focusPath, ...props } = properties\n    const { document } = value\n\n    if (anchorPath !== undefined) {\n      props.anchorKey =\n        anchorPath === null ? null : document.assertPath(anchorPath).key\n    }\n\n    if (focusPath !== undefined) {\n      props.focusKey =\n        focusPath === null ? null : document.assertPath(focusPath).key\n    }\n\n    const inverseSelection = selection.merge(props)\n    const inverseProps = pick(selection, Object.keys(props))\n\n    if (anchorPath !== undefined) {\n      inverseProps.anchorPath =\n        inverseProps.anchorKey === null\n          ? null\n          : document.getPath(inverseProps.anchorKey)\n      delete inverseProps.anchorKey\n    }\n\n    if (focusPath !== undefined) {\n      inverseProps.focusPath =\n        inverseProps.focusKey === null\n          ? null\n          : document.getPath(inverseProps.focusKey)\n      delete inverseProps.focusKey\n    }\n\n    const inverse = op\n      .set('selection', inverseSelection)\n      .set('properties', inverseProps)\n    return inverse\n  }\n\n  /**\n   * Set value.\n   */\n\n  if (type == 'set_value') {\n    const { properties, value } = op\n    const inverseValue = value.merge(properties)\n    const inverseProperties = pick(value, Object.keys(properties))\n    const inverse = op\n      .set('value', inverseValue)\n      .set('properties', inverseProperties)\n    return inverse\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default invertOperation\n","import invert from '../operations/invert'\nimport omit from 'lodash/omit'\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nconst Changes = {}\n\n/**\n * Redo to the next value in the history.\n *\n * @param {Change} change\n */\n\nChanges.redo = change => {\n  let { value } = change\n  let { history } = value\n  if (!history) return\n\n  let { undos, redos } = history\n  const next = redos.peek()\n  if (!next) return\n\n  // Shift the next value into the undo stack.\n  redos = redos.pop()\n  undos = undos.push(next)\n\n  // Replay the next operations.\n  next.forEach(op => {\n    const { type, properties } = op\n\n    // When the operation mutates the selection, omit its `isFocused` value to\n    // prevent the editor focus from changing during redoing.\n    if (type == 'set_selection') {\n      op = op.set('properties', omit(properties, 'isFocused'))\n    }\n\n    change.applyOperation(op, { save: false })\n  })\n\n  // Update the history.\n  value = change.value\n  history = history.set('undos', undos).set('redos', redos)\n  value = value.set('history', history)\n  change.value = value\n}\n\n/**\n * Undo the previous operations in the history.\n *\n * @param {Change} change\n */\n\nChanges.undo = change => {\n  let { value } = change\n  let { history } = value\n  if (!history) return\n\n  let { undos, redos } = history\n  const previous = undos.peek()\n  if (!previous) return\n\n  // Shift the previous operations into the redo stack.\n  undos = undos.pop()\n  redos = redos.push(previous)\n\n  // Replay the inverse of the previous operations.\n  previous\n    .slice()\n    .reverse()\n    .map(invert)\n    .forEach(inverse => {\n      const { type, properties } = inverse\n\n      // When the operation mutates the selection, omit its `isFocused` value to\n      // prevent the editor focus from changing during undoing.\n      if (type == 'set_selection') {\n        inverse = inverse.set('properties', omit(properties, 'isFocused'))\n      }\n\n      change.applyOperation(inverse, { save: false })\n    })\n\n  // Update the history.\n  value = change.value\n  history = history.set('undos', undos).set('redos', redos)\n  value = value.set('history', history)\n  change.value = value\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Changes\n","import isEmpty from 'is-empty'\nimport pick from 'lodash/pick'\n\nimport Range from '../models/range'\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nconst Changes = {}\n\n/**\n * Set `properties` on the selection.\n *\n * @param {Change} change\n * @param {Object} properties\n */\n\nChanges.select = (change, properties, options = {}) => {\n  properties = Range.createProperties(properties)\n\n  const { snapshot = false } = options\n  const { value } = change\n  const { document, selection } = value\n  const props = {}\n  const sel = selection.toJSON()\n  const next = selection.merge(properties).normalize(document)\n  properties = pick(next, Object.keys(properties))\n\n  // Remove any properties that are already equal to the current selection. And\n  // create a dictionary of the previous values for all of the properties that\n  // are being changed, for the inverse operation.\n  for (const k in properties) {\n    if (snapshot == false && properties[k] == sel[k]) continue\n    props[k] = properties[k]\n  }\n\n  // If the selection moves, clear any marks, unless the new selection\n  // properties change the marks in some way.\n  const moved = ['anchorKey', 'anchorOffset', 'focusKey', 'focusOffset'].some(\n    p => props.hasOwnProperty(p)\n  )\n\n  if (sel.marks && properties.marks == sel.marks && moved) {\n    props.marks = null\n  }\n\n  // If there are no new properties to set, abort.\n  if (isEmpty(props)) {\n    return\n  }\n\n  // Apply the operation.\n  change.applyOperation(\n    {\n      type: 'set_selection',\n      value,\n      properties: props,\n      selection: sel,\n    },\n    snapshot ? { skip: false, merge: false } : {}\n  )\n}\n\n/**\n * Select the whole document.\n *\n * @param {Change} change\n */\n\nChanges.selectAll = change => {\n  const { value } = change\n  const { document, selection } = value\n  const next = selection.moveToRangeOf(document)\n  change.select(next)\n}\n\n/**\n * Snapshot the current selection.\n *\n * @param {Change} change\n */\n\nChanges.snapshotSelection = change => {\n  const { value } = change\n  const { selection } = value\n  change.select(selection, { snapshot: true })\n}\n\n/**\n * Move the anchor point backward, accounting for being at the start of a block.\n *\n * @param {Change} change\n */\n\nChanges.moveAnchorCharBackward = change => {\n  const { value } = change\n  const { document, selection, anchorText, anchorBlock } = value\n  const { anchorOffset } = selection\n  const previousText = document.getPreviousText(anchorText.key)\n  const isInVoid = document.hasVoidParent(anchorText.key)\n  const isPreviousInVoid =\n    previousText && document.hasVoidParent(previousText.key)\n\n  if (!isInVoid && anchorOffset > 0) {\n    change.moveAnchor(-1)\n    return\n  }\n\n  if (!previousText) {\n    return\n  }\n\n  change.moveAnchorToEndOf(previousText)\n\n  if (!isInVoid && !isPreviousInVoid && anchorBlock.hasNode(previousText.key)) {\n    change.moveAnchor(-1)\n  }\n}\n\n/**\n * Move the anchor point forward, accounting for being at the end of a block.\n *\n * @param {Change} change\n */\n\nChanges.moveAnchorCharForward = change => {\n  const { value } = change\n  const { document, selection, anchorText, anchorBlock } = value\n  const { anchorOffset } = selection\n  const nextText = document.getNextText(anchorText.key)\n  const isInVoid = document.hasVoidParent(anchorText.key)\n  const isNextInVoid = nextText && document.hasVoidParent(nextText.key)\n\n  if (!isInVoid && anchorOffset < anchorText.text.length) {\n    change.moveAnchor(1)\n    return\n  }\n\n  if (!nextText) {\n    return\n  }\n\n  change.moveAnchorToStartOf(nextText)\n\n  if (!isInVoid && !isNextInVoid && anchorBlock.hasNode(nextText.key)) {\n    change.moveAnchor(1)\n  }\n}\n\n/**\n * Move the focus point backward, accounting for being at the start of a block.\n *\n * @param {Change} change\n */\n\nChanges.moveFocusCharBackward = change => {\n  const { value } = change\n  const { document, selection, focusText, focusBlock } = value\n  const { focusOffset } = selection\n  const previousText = document.getPreviousText(focusText.key)\n  const isInVoid = document.hasVoidParent(focusText.key)\n  const isPreviousInVoid =\n    previousText && document.hasVoidParent(previousText.key)\n\n  if (!isInVoid && focusOffset > 0) {\n    change.moveFocus(-1)\n    return\n  }\n\n  if (!previousText) {\n    return\n  }\n\n  change.moveFocusToEndOf(previousText)\n\n  if (!isInVoid && !isPreviousInVoid && focusBlock.hasNode(previousText.key)) {\n    change.moveFocus(-1)\n  }\n}\n\n/**\n * Move the focus point forward, accounting for being at the end of a block.\n *\n * @param {Change} change\n */\n\nChanges.moveFocusCharForward = change => {\n  const { value } = change\n  const { document, selection, focusText, focusBlock } = value\n  const { focusOffset } = selection\n  const nextText = document.getNextText(focusText.key)\n  const isInVoid = document.hasVoidParent(focusText.key)\n  const isNextInVoid = nextText && document.hasVoidParent(nextText.key)\n\n  if (!isInVoid && focusOffset < focusText.text.length) {\n    change.moveFocus(1)\n    return\n  }\n\n  if (!nextText) {\n    return\n  }\n\n  change.moveFocusToStartOf(nextText)\n\n  if (!isInVoid && !isNextInVoid && focusBlock.hasNode(nextText.key)) {\n    change.moveFocus(1)\n  }\n}\n\n/**\n * Mix in move methods.\n */\n\nconst MOVE_DIRECTIONS = ['Forward', 'Backward']\n\nMOVE_DIRECTIONS.forEach(direction => {\n  const anchor = `moveAnchorChar${direction}`\n  const focus = `moveFocusChar${direction}`\n\n  Changes[`moveChar${direction}`] = change => {\n    change[anchor]()[focus]()\n  }\n\n  Changes[`moveStartChar${direction}`] = change => {\n    if (change.value.isBackward) {\n      change[focus]()\n    } else {\n      change[anchor]()\n    }\n  }\n\n  Changes[`moveEndChar${direction}`] = change => {\n    if (change.value.isBackward) {\n      change[anchor]()\n    } else {\n      change[focus]()\n    }\n  }\n\n  Changes[`extendChar${direction}`] = change => {\n    change[`moveFocusChar${direction}`]()\n  }\n\n  Changes[`collapseChar${direction}`] = change => {\n    const collapse =\n      direction == 'Forward' ? 'collapseToEnd' : 'collapseToStart'\n    change[collapse]()[`moveChar${direction}`]()\n  }\n})\n\n/**\n * Mix in alias methods.\n */\n\nconst ALIAS_METHODS = [\n  ['collapseLineBackward', 'collapseToStartOfBlock'],\n  ['collapseLineForward', 'collapseToEndOfBlock'],\n  ['extendLineBackward', 'extendToStartOfBlock'],\n  ['extendLineForward', 'extendToEndOfBlock'],\n]\n\nALIAS_METHODS.forEach(([alias, method]) => {\n  Changes[alias] = function(change, ...args) {\n    change[method](change, ...args)\n  }\n})\n\n/**\n * Mix in selection changes that are just a proxy for the selection method.\n */\n\nconst PROXY_TRANSFORMS = [\n  'blur',\n  'collapseTo',\n  'collapseToAnchor',\n  'collapseToEnd',\n  'collapseToEndOf',\n  'collapseToFocus',\n  'collapseToStart',\n  'collapseToStartOf',\n  'extend',\n  'extendTo',\n  'extendToEndOf',\n  'extendToStartOf',\n  'flip',\n  'focus',\n  'move',\n  'moveAnchor',\n  'moveAnchorOffsetTo',\n  'moveAnchorTo',\n  'moveAnchorToEndOf',\n  'moveAnchorToStartOf',\n  'moveEnd',\n  'moveEndOffsetTo',\n  'moveEndTo',\n  'moveFocus',\n  'moveFocusOffsetTo',\n  'moveFocusTo',\n  'moveFocusToEndOf',\n  'moveFocusToStartOf',\n  'moveOffsetsTo',\n  'moveStart',\n  'moveStartOffsetTo',\n  'moveStartTo',\n  'moveTo',\n  'moveToEnd',\n  'moveToEndOf',\n  'moveToRangeOf',\n  'moveToStart',\n  'moveToStartOf',\n  'deselect',\n]\n\nPROXY_TRANSFORMS.forEach(method => {\n  Changes[method] = (change, ...args) => {\n    const normalize = method != 'deselect'\n    const { value } = change\n    const { document, selection } = value\n    let next = selection[method](...args)\n    if (normalize) next = next.normalize(document)\n    change.select(next)\n  }\n})\n\n/**\n * Mix in node-related changes.\n */\n\nconst PREFIXES = [\n  'moveTo',\n  'moveAnchorTo',\n  'moveFocusTo',\n  'moveStartTo',\n  'moveEndTo',\n  'collapseTo',\n  'extendTo',\n]\n\nconst DIRECTIONS = ['Next', 'Previous']\n\nconst OBJECTS = ['Block', 'Inline', 'Text']\n\nPREFIXES.forEach(prefix => {\n  const edges = ['Start', 'End']\n\n  if (prefix == 'moveTo') {\n    edges.push('Range')\n  }\n\n  edges.forEach(edge => {\n    const method = `${prefix}${edge}Of`\n\n    OBJECTS.forEach(object => {\n      const getNode = object == 'Text' ? 'getNode' : `getClosest${object}`\n\n      Changes[`${method}${object}`] = change => {\n        const { value } = change\n        const { document, selection } = value\n        const node = document[getNode](selection.startKey)\n        if (!node) return\n        change[method](node)\n      }\n\n      DIRECTIONS.forEach(direction => {\n        const getDirectionNode = `get${direction}${object}`\n        const directionKey = direction == 'Next' ? 'startKey' : 'endKey'\n\n        Changes[`${method}${direction}${object}`] = change => {\n          const { value } = change\n          const { document, selection } = value\n          const node = document[getNode](selection[directionKey])\n          if (!node) return\n          const target = document[getDirectionNode](node.key)\n          if (!target) return\n          change[method](target)\n        }\n      })\n    })\n  })\n})\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Changes\n","import Value from '../models/value'\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nconst Changes = {}\n\n/**\n * Set `properties` on the value.\n *\n * @param {Change} change\n * @param {Object|Value} properties\n * @param {Object} options\n */\n\nChanges.setValue = (change, properties, options = {}) => {\n  properties = Value.createProperties(properties)\n  const { value } = change\n\n  change.applyOperation(\n    {\n      type: 'set_value',\n      properties,\n      value,\n    },\n    options\n  )\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Changes\n","/**\n * Changes.\n *\n * @type {Object}\n */\n\nconst Changes = {}\n\n/**\n * Normalize the value with its schema.\n *\n * @param {Change} change\n */\n\nChanges.normalize = change => {\n  change.normalizeDocument()\n}\n\n/**\n * Normalize the document with the value's schema.\n *\n * @param {Change} change\n */\n\nChanges.normalizeDocument = change => {\n  const { value } = change\n  const { document } = value\n  change.normalizeNodeByKey(document.key)\n}\n\n/**\n * Normalize a `node` and its children with the value's schema.\n *\n * @param {Change} change\n * @param {Node|String} key\n */\n\nChanges.normalizeNodeByKey = (change, key) => {\n  const { value } = change\n  let { document, schema } = value\n  const node = document.assertNode(key)\n\n  normalizeNodeAndChildren(change, node, schema)\n\n  document = change.value.document\n  const ancestors = document.getAncestors(key)\n  if (!ancestors) return\n\n  ancestors.forEach(ancestor => {\n    normalizeNode(change, ancestor, schema)\n  })\n}\n\n/**\n * Normalize a `node` and its children with a `schema`.\n *\n * @param {Change} change\n * @param {Node} node\n * @param {Schema} schema\n */\n\nfunction normalizeNodeAndChildren(change, node, schema) {\n  if (node.object == 'text') {\n    normalizeNode(change, node, schema)\n    return\n  }\n\n  const normalizedKeys = []\n  let child = node.nodes.first()\n  let path = change.value.document.getPath(node.key)\n\n  // We can't just loop the children and normalize them, because in the process\n  // of normalizing one child, we might end up creating another. Instead, we\n  // have to normalize one at a time, and check for new children along the way.\n  while (node && child) {\n    const lastSize = change.operations.size\n    normalizeNodeAndChildren(change, child, schema)\n    normalizedKeys.push(child.key)\n\n    // PERF: if size is unchanged, then no operation happens\n    // Therefore we can simply normalize the next child\n    if (lastSize === change.operations.size) {\n      const nextIndex = node.nodes.indexOf(child) + 1\n      child = node.nodes.get(nextIndex)\n    } else {\n      node = change.value.document.refindNode(path, node.key)\n      if (!node) {\n        path = []\n        child = null\n      } else {\n        path = change.value.document.refindPath(path, node.key)\n        child = node.nodes.find(c => !normalizedKeys.includes(c.key))\n      }\n    }\n  }\n\n  // Normalize the node itself if it still exists.\n  if (node) {\n    normalizeNode(change, node, schema)\n  }\n}\n\n/**\n * Normalize a `node` with a `schema`, but not its children.\n *\n * @param {Change} change\n * @param {Node} node\n * @param {Schema} schema\n */\n\nfunction normalizeNode(change, node, schema) {\n  const max = schema.stack.plugins.length + 1\n  let iterations = 0\n\n  function iterate(c, n) {\n    const normalize = n.validate(schema)\n    if (!normalize) return\n\n    // Run the `normalize` function to fix the node.\n    let path = c.value.document.getPath(n.key)\n    normalize(c)\n\n    // Re-find the node reference, in case it was updated. If the node no longer\n    // exists, we're done for this branch.\n    n = c.value.document.refindNode(path, n.key)\n    if (!n) return\n\n    path = c.value.document.refindPath(path, n.key)\n\n    // Increment the iterations counter, and check to make sure that we haven't\n    // exceeded the max. Without this check, it's easy for the `validate` or\n    // `normalize` function of a schema rule to be written incorrectly and for\n    // an infinite invalid loop to occur.\n    iterations++\n\n    if (iterations > max) {\n      throw new Error(\n        'A schema rule could not be validated after sufficient iterations. This is usually due to a `rule.validate` or `rule.normalize` function of a schema being incorrectly written, causing an infinite loop.'\n      )\n    }\n\n    // Otherwise, iterate again.\n    iterate(c, n)\n  }\n\n  iterate(change, node)\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Changes\n","import AtCurrentRange from './at-current-range'\nimport AtRange from './at-range'\nimport ByKey from './by-key'\nimport OnHistory from './on-history'\nimport OnSelection from './on-selection'\nimport OnValue from './on-value'\nimport WithSchema from './with-schema'\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  ...AtCurrentRange,\n  ...AtRange,\n  ...ByKey,\n  ...OnHistory,\n  ...OnSelection,\n  ...OnValue,\n  ...WithSchema,\n}\n","import Debug from 'debug'\n\nimport Operation from '../models/operation'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:operation:apply')\n\n/**\n * Applying functions.\n *\n * @type {Object}\n */\n\nconst APPLIERS = {\n  /**\n   * Add mark to text at `offset` and `length` in node by `path`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  add_mark(value, operation) {\n    const { path, offset, length, mark } = operation\n    let { document } = value\n    let node = document.assertPath(path)\n    node = node.addMark(offset, length, mark)\n    document = document.updateNode(node)\n    value = value.set('document', document)\n    return value\n  },\n\n  /**\n   * Insert a `node` at `index` in a node by `path`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  insert_node(value, operation) {\n    const { path, node } = operation\n    const index = path[path.length - 1]\n    const rest = path.slice(0, -1)\n    let { document } = value\n    let parent = document.assertPath(rest)\n    parent = parent.insertNode(index, node)\n    document = document.updateNode(parent)\n    value = value.set('document', document)\n    return value\n  },\n\n  /**\n   * Insert `text` at `offset` in node by `path`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  insert_text(value, operation) {\n    const { path, offset, text, marks } = operation\n    let { document, selection } = value\n    const { anchorKey, focusKey, anchorOffset, focusOffset } = selection\n    let node = document.assertPath(path)\n\n    // Update the document\n    node = node.insertText(offset, text, marks)\n    document = document.updateNode(node)\n\n    // Update the selection\n    if (anchorKey == node.key && anchorOffset >= offset) {\n      selection = selection.moveAnchor(text.length)\n    }\n    if (focusKey == node.key && focusOffset >= offset) {\n      selection = selection.moveFocus(text.length)\n    }\n\n    value = value.set('document', document).set('selection', selection)\n    return value\n  },\n\n  /**\n   * Merge a node at `path` with the previous node.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  merge_node(value, operation) {\n    const { path } = operation\n    const withPath = path\n      .slice(0, path.length - 1)\n      .concat([path[path.length - 1] - 1])\n    let { document, selection } = value\n    const one = document.assertPath(withPath)\n    const two = document.assertPath(path)\n    let parent = document.getParent(one.key)\n    const oneIndex = parent.nodes.indexOf(one)\n    const twoIndex = parent.nodes.indexOf(two)\n\n    // Perform the merge in the document.\n    parent = parent.mergeNode(oneIndex, twoIndex)\n    document = document.updateNode(parent)\n\n    // If the nodes are text nodes and the selection is inside the second node\n    // update it to refer to the first node instead.\n    if (one.object == 'text') {\n      const { anchorKey, anchorOffset, focusKey, focusOffset } = selection\n      let normalize = false\n\n      if (anchorKey == two.key) {\n        selection = selection.moveAnchorTo(\n          one.key,\n          one.text.length + anchorOffset\n        )\n        normalize = true\n      }\n\n      if (focusKey == two.key) {\n        selection = selection.moveFocusTo(\n          one.key,\n          one.text.length + focusOffset\n        )\n        normalize = true\n      }\n\n      if (normalize) {\n        selection = selection.normalize(document)\n      }\n    }\n\n    // Update the document and selection.\n    value = value.set('document', document).set('selection', selection)\n    return value\n  },\n\n  /**\n   * Move a node by `path` to `newPath`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  move_node(value, operation) {\n    const { path, newPath } = operation\n    const newIndex = newPath[newPath.length - 1]\n    const newParentPath = newPath.slice(0, -1)\n    const oldParentPath = path.slice(0, -1)\n    const oldIndex = path[path.length - 1]\n    let { document } = value\n    const node = document.assertPath(path)\n\n    // Remove the node from its current parent.\n    let parent = document.getParent(node.key)\n    parent = parent.removeNode(oldIndex)\n    document = document.updateNode(parent)\n\n    // Find the new target...\n    let target\n\n    // If the old path and the rest of the new path are the same, then the new\n    // target is the old parent.\n    if (\n      oldParentPath.every((x, i) => x === newParentPath[i]) &&\n      oldParentPath.length === newParentPath.length\n    ) {\n      target = parent\n    } else if (\n      oldParentPath.every((x, i) => x === newParentPath[i]) &&\n      oldIndex < newParentPath[oldParentPath.length]\n    ) {\n      // Otherwise, if the old path removal resulted in the new path being no longer\n      // correct, we need to decrement the new path at the old path's last index.\n      newParentPath[oldParentPath.length]--\n      target = document.assertPath(newParentPath)\n    } else {\n      // Otherwise, we can just grab the target normally...\n      target = document.assertPath(newParentPath)\n    }\n\n    // Insert the new node to its new parent.\n    target = target.insertNode(newIndex, node)\n    document = document.updateNode(target)\n    value = value.set('document', document)\n    return value\n  },\n\n  /**\n   * Remove mark from text at `offset` and `length` in node by `path`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  remove_mark(value, operation) {\n    const { path, offset, length, mark } = operation\n    let { document } = value\n    let node = document.assertPath(path)\n    node = node.removeMark(offset, length, mark)\n    document = document.updateNode(node)\n    value = value.set('document', document)\n    return value\n  },\n\n  /**\n   * Remove a node by `path`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  remove_node(value, operation) {\n    const { path } = operation\n    let { document, selection } = value\n    const { startKey, endKey } = selection\n    const node = document.assertPath(path)\n\n    // If the selection is set, check to see if it needs to be updated.\n    if (selection.isSet) {\n      const hasStartNode = node.hasNode(startKey)\n      const hasEndNode = node.hasNode(endKey)\n      const first = node.object == 'text' ? node : node.getFirstText() || node\n      const last = node.object == 'text' ? node : node.getLastText() || node\n      const prev = document.getPreviousText(first.key)\n      const next = document.getNextText(last.key)\n\n      // If the start point was in this node, update it to be just before/after.\n      if (hasStartNode) {\n        if (prev) {\n          selection = selection.moveStartTo(prev.key, prev.text.length)\n        } else if (next) {\n          selection = selection.moveStartTo(next.key, 0)\n        } else {\n          selection = selection.deselect()\n        }\n      }\n\n      // If the end point was in this node, update it to be just before/after.\n      if (selection.isSet && hasEndNode) {\n        if (prev) {\n          selection = selection.moveEndTo(prev.key, prev.text.length)\n        } else if (next) {\n          selection = selection.moveEndTo(next.key, 0)\n        } else {\n          selection = selection.deselect()\n        }\n      }\n\n      // If the selection wasn't deselected, normalize it.\n      if (selection.isSet) {\n        selection = selection.normalize(document)\n      }\n    }\n\n    // Remove the node from the document.\n    let parent = document.getParent(node.key)\n    const index = parent.nodes.indexOf(node)\n    parent = parent.removeNode(index)\n    document = document.updateNode(parent)\n\n    // Update the document and selection.\n    value = value.set('document', document).set('selection', selection)\n    return value\n  },\n\n  /**\n   * Remove `text` at `offset` in node by `path`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  remove_text(value, operation) {\n    const { path, offset, text } = operation\n    const { length } = text\n    const rangeOffset = offset + length\n    let { document, selection } = value\n    const { anchorKey, focusKey, anchorOffset, focusOffset } = selection\n    let node = document.assertPath(path)\n\n    if (anchorKey == node.key) {\n      if (anchorOffset >= rangeOffset) {\n        selection = selection.moveAnchor(-length)\n      } else if (anchorOffset > offset) {\n        selection = selection.moveAnchorTo(anchorKey, offset)\n      }\n    }\n\n    if (focusKey == node.key) {\n      if (focusOffset >= rangeOffset) {\n        selection = selection.moveFocus(-length)\n      } else if (focusOffset > offset) {\n        selection = selection.moveFocusTo(focusKey, offset)\n      }\n    }\n\n    node = node.removeText(offset, length)\n    document = document.updateNode(node)\n    value = value.set('document', document).set('selection', selection)\n    return value\n  },\n\n  /**\n   * Set `properties` on mark on text at `offset` and `length` in node by `path`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  set_mark(value, operation) {\n    const { path, offset, length, mark, properties } = operation\n    let { document } = value\n    let node = document.assertPath(path)\n    node = node.updateMark(offset, length, mark, properties)\n    document = document.updateNode(node)\n    value = value.set('document', document)\n    return value\n  },\n\n  /**\n   * Set `properties` on a node by `path`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  set_node(value, operation) {\n    const { path, properties } = operation\n    let { document } = value\n    let node = document.assertPath(path)\n    node = node.merge(properties)\n    document = document.updateNode(node)\n    value = value.set('document', document)\n    return value\n  },\n\n  /**\n   * Set `properties` on the selection.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  set_selection(value, operation) {\n    const { properties } = operation\n    const { anchorPath, focusPath, ...props } = properties\n    let { document, selection } = value\n\n    if (anchorPath !== undefined) {\n      props.anchorKey =\n        anchorPath === null ? null : document.assertPath(anchorPath).key\n    }\n\n    if (focusPath !== undefined) {\n      props.focusKey =\n        focusPath === null ? null : document.assertPath(focusPath).key\n    }\n\n    selection = selection.merge(props)\n    selection = selection.normalize(document)\n    value = value.set('selection', selection)\n    return value\n  },\n\n  /**\n   * Set `properties` on `value`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  set_value(value, operation) {\n    const { properties } = operation\n    value = value.merge(properties)\n    return value\n  },\n\n  /**\n   * Split a node by `path` at `offset`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  split_node(value, operation) {\n    const { path, position, properties } = operation\n    let { document, selection } = value\n\n    // Calculate a few things...\n    const node = document.assertPath(path)\n    let parent = document.getParent(node.key)\n    const index = parent.nodes.indexOf(node)\n\n    // Split the node by its parent.\n    parent = parent.splitNode(index, position)\n    if (properties) {\n      const splitNode = parent.nodes.get(index + 1)\n      if (splitNode.object !== 'text') {\n        parent = parent.updateNode(splitNode.merge(properties))\n      }\n    }\n    document = document.updateNode(parent)\n\n    // Determine whether we need to update the selection...\n    const { startKey, endKey, startOffset, endOffset } = selection\n    const next = document.getNextText(node.key)\n    let normalize = false\n\n    // If the start point is after or equal to the split, update it.\n    if (node.key == startKey && position <= startOffset) {\n      selection = selection.moveStartTo(next.key, startOffset - position)\n      normalize = true\n    }\n\n    // If the end point is after or equal to the split, update it.\n    if (node.key == endKey && position <= endOffset) {\n      selection = selection.moveEndTo(next.key, endOffset - position)\n      normalize = true\n    }\n\n    // Normalize the selection if we changed it, since the methods we use might\n    // leave it in a non-normalized value.\n    if (normalize) {\n      selection = selection.normalize(document)\n    }\n\n    // Return the updated value.\n    value = value.set('document', document).set('selection', selection)\n    return value\n  },\n}\n\n/**\n * Apply an `operation` to a `value`.\n *\n * @param {Value} value\n * @param {Object|Operation} operation\n * @return {Value} value\n */\n\nfunction applyOperation(value, operation) {\n  operation = Operation.create(operation)\n  const { type } = operation\n  const apply = APPLIERS[type]\n\n  if (!apply) {\n    throw new Error(`Unknown operation type: \"${type}\".`)\n  }\n\n  debug(type, operation)\n  value = apply(value, operation)\n  return value\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default applyOperation\n","import Debug from 'debug'\nimport isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport pick from 'lodash/pick'\nimport { List } from 'immutable'\n\nimport MODEL_TYPES from '../constants/model-types'\nimport Changes from '../changes'\nimport Operation from './operation'\nimport apply from '../operations/apply'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:change')\n\n/**\n * Change.\n *\n * @type {Change}\n */\n\nclass Change {\n  /**\n   * Check if `any` is a `Change`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isChange(any) {\n    return !!(any && any[MODEL_TYPES.CHANGE])\n  }\n\n  /**\n   * Create a new `Change` with `attrs`.\n   *\n   * @param {Object} attrs\n   *   @property {Value} value\n   */\n\n  constructor(attrs) {\n    const { value } = attrs\n    this.value = value\n    this.operations = new List()\n    this.flags = {\n      normalize: true,\n      ...pick(attrs, ['merge', 'save', 'normalize']),\n    }\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'change'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Apply an `operation` to the current value, saving the operation to the\n   * history if needed.\n   *\n   * @param {Operation|Object} operation\n   * @param {Object} options\n   * @return {Change}\n   */\n\n  applyOperation(operation, options = {}) {\n    const { operations, flags } = this\n    let { value } = this\n    let { history } = value\n\n    // Add in the current `value` in case the operation was serialized.\n    if (isPlainObject(operation)) {\n      operation = { ...operation, value }\n    }\n\n    operation = Operation.create(operation)\n\n    // Default options to the change-level flags, this allows for setting\n    // specific options for all of the operations of a given change.\n    options = { ...flags, ...options }\n\n    // Derive the default option values.\n    const {\n      merge = operations.size == 0 ? null : true,\n      save = true,\n      skip = null,\n    } = options\n\n    // Apply the operation to the value.\n    debug('apply', { operation, save, merge })\n    value = apply(value, operation)\n\n    // If needed, save the operation to the history.\n    if (history && save) {\n      history = history.save(operation, { merge, skip })\n      value = value.set('history', history)\n    }\n\n    // Update the mutable change object.\n    this.value = value\n    this.operations = operations.push(operation)\n    return this\n  }\n\n  /**\n   * Apply a series of `operations` to the current value.\n   *\n   * @param {Array|List} operations\n   * @param {Object} options\n   * @return {Change}\n   */\n\n  applyOperations(operations, options) {\n    operations.forEach(op => this.applyOperation(op, options))\n    return this\n  }\n\n  /**\n   * Call a change `fn` with arguments.\n   *\n   * @param {Function} fn\n   * @param {Mixed} ...args\n   * @return {Change}\n   */\n\n  call(fn, ...args) {\n    fn(this, ...args)\n    return this\n  }\n\n  /**\n   * Applies a series of change mutations and defers normalization until the end.\n   *\n   * @param {Function} customChange - function that accepts a change object and executes change operations\n   * @return {Change}\n   */\n\n  withoutNormalization(customChange) {\n    const original = this.flags.normalize\n    this.setOperationFlag('normalize', false)\n    try {\n      customChange(this)\n      // if the change function worked then run normalization\n      this.normalizeDocument()\n    } finally {\n      // restore the flag to whatever it was\n      this.setOperationFlag('normalize', original)\n    }\n    return this\n  }\n\n  /**\n   * Set an operation flag by `key` to `value`.\n   *\n   * @param {String} key\n   * @param {Any} value\n   * @return {Change}\n   */\n\n  setOperationFlag(key, value) {\n    this.flags[key] = value\n    return this\n  }\n\n  /**\n   * Get the `value` of the specified flag by its `key`. Optionally accepts an `options`\n   * object with override flags.\n   *\n   * @param {String} key\n   * @param {Object} options\n   * @return {Change}\n   */\n\n  getFlag(key, options = {}) {\n    return options[key] !== undefined ? options[key] : this.flags[key]\n  }\n\n  /**\n   * Unset an operation flag by `key`.\n   *\n   * @param {String} key\n   * @return {Change}\n   */\n\n  unsetOperationFlag(key) {\n    delete this.flags[key]\n    return this\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nChange.prototype[MODEL_TYPES.CHANGE] = true\n\n/**\n * Add a change method for each of the changes.\n */\n\nObject.keys(Changes).forEach(type => {\n  Change.prototype[type] = function(...args) {\n    debug(type, { args })\n    this.call(Changes[type], ...args)\n    return this\n  }\n})\n\n/**\n * Export.\n *\n * @type {Change}\n */\n\nexport default Change\n","import apply from './apply'\nimport invert from './invert'\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  apply,\n  invert,\n}\n","import Block from './models/block'\nimport Change from './models/change'\nimport Changes from './changes'\nimport Character from './models/character'\nimport Data from './models/data'\nimport Document from './models/document'\nimport History from './models/history'\nimport Inline from './models/inline'\nimport Leaf from './models/leaf'\nimport Mark from './models/mark'\nimport Node from './models/node'\nimport Operation from './models/operation'\nimport Operations from './operations'\nimport Range from './models/range'\nimport Schema from './models/schema'\nimport Stack from './models/stack'\nimport Text from './models/text'\nimport Value from './models/value'\nimport { resetKeyGenerator, setKeyGenerator } from './utils/generate-key'\nimport { resetMemoization, useMemoization } from './utils/memoize'\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport {\n  Block,\n  Change,\n  Changes,\n  Character,\n  Data,\n  Document,\n  History,\n  Inline,\n  Leaf,\n  Mark,\n  Node,\n  Operation,\n  Operations,\n  Range,\n  Schema,\n  Stack,\n  Text,\n  Value,\n  resetKeyGenerator,\n  setKeyGenerator,\n  resetMemoization,\n  useMemoization,\n}\n\nexport default {\n  Block,\n  Changes,\n  Character,\n  Data,\n  Document,\n  History,\n  Inline,\n  Leaf,\n  Mark,\n  Node,\n  Operation,\n  Operations,\n  Range,\n  Schema,\n  Stack,\n  Text,\n  Value,\n  resetKeyGenerator,\n  setKeyGenerator,\n  resetMemoization,\n  useMemoization,\n}\n"],"names":["Data","attrs","Map","isMap","isPlainObject","fromJSON","Error","object","fromJS","MODEL_TYPES","global","IS_DEV","process","env","ENABLED","CACHE_KEY","LEAF","UNDEFINED","UNSET","undefined","memoize","properties","options","takesArguments","property","original","args","apply","__cache_key","__cache","cachedValue","keys","getIn","get","value","v","setIn","set","map","key","parent","child","resetMemoization","Number","MAX_SAFE_INTEGER","useMemoization","enabled","DEFAULTS","Mark","schema","__getComponent","type","data","toJSON","deprecate","isMark","elements","Set","isSet","Array","isArray","marks","create","props","mark","any","MARK","every","item","Record","prototype","Range","node","anchorOffset","first","getFirst","anchorKey","last","getLast","text","length","start","end","hasAnchorIn","hasDescendant","focusKey","focusOffset","hasFocusIn","isCollapsed","hasAnchorAtStartOf","hasAnchorAtEndOf","merge","isBackward","n","offset","moveAnchorOffsetTo","moveFocusOffsetTo","moveFocusTo","moveAnchorTo","range","flip","moveAnchorToStartOf","moveFocusToEndOf","anchorOffsetType","focusOffsetType","warn","anchorNode","getDescendant","focusNode","getFirstText","anchorText","getTextAtOffset","getOffset","focusText","areDescendantsSorted","isFocused","toArray","m","isRange","List","isList","list","anchorPath","focusPath","createSet","obj","RANGE","MOVE_METHODS","forEach","p","s","EDGE_METHODS","hasEdge","anchor","focus","ALIAS_METHODS","alias","method","getLastText","Character","isCharacter","split","character","CHARACTER","Leaf","characters","createList","char","isLeaf","leaf","generate","generateKey","setKeyGenerator","func","resetKeyGenerator","Text","index","addMarks","i","union","decorations","size","startKey","endKey","startOffset","endOffset","hasStart","hasEnd","__getDecorations","getDecoratedCharacters","leaves","prevChar","prevLeaf","push","prevMarks","isSame","is","array","getMarksAsArray","OrderedSet","reduce","concat","getNode","chars","slice","remove","filterNot","getLeaves","r","preserveKeys","newMark","has","add","validateNode","string","isText","l","getCharacters","TEXT","isIndexInRange","Node","second","assertKey","getKeysAsArray","firstIndex","indexOf","secondIndex","getChild","descendant","path","getDescendantAtPath","iterator","matches","forEachDescendant","nodes","found","ret","hasChild","ancestors","find","getAncestors","unshift","getBlocksAsArray","isLeafBlock","getBlocksAtRangeAsArray","normalize","isUnset","startBlock","getClosestBlock","endBlock","blocks","getBlocksByTypeAsArray","getCharactersAsArray","arr","getCharactersAtRangeAsArray","getTextsAtRange","filter","rest","findLast","getClosest","isVoid","one","two","assertDescendant","oneParent","getParent","twoParent","includes","stack","startAt","getFurthestAncestor","getDepth","descendantFound","Document","startText","endText","previous","position","splitNode","updateNode","getNextText","startNode","getNextSibling","endNode","startIndex","endIndex","getFurthest","skipLast","reverse","takeUntil","getInlinesAsArray","isLeafInline","getInlinesAtRangeAsArray","getTextsAtRangeAsArray","getClosestInline","exists","getInlinesByTypeAsArray","inlines","desc","getMarksAtRangeAsArray","getInsertMarksAtRangeAsArray","getActiveMarksAtRangeAsArray","getMarksAtCollapsedRangeAsArray","getCharactersAtRange","memo","c","getPreviousText","intersect","getMarksByTypeAsArray","block","next","after","skipUntil","getTexts","isExpanded","assertNode","ancestor","getPath","__getPlaceholder","before","isSelected","isBlurred","dir","direction","getTextsAsArray","texts","regenerateKey","mapDescendants","insert","withIndex","removeNode","insertNode","findIndex","splice","befores","take","afters","skip","isNode","kind","Block","Inline","isBlock","isInline","isDocument","arg","getText","inline","INLINE","Object","getOwnPropertyNames","document","DOCUMENT","BLOCK","Changes","PROXY_TRANSFORMS","change","selection","methodAtRange","addMark","addMarkAtRange","sel","select","getActiveMarksAtRange","delete","deleteAtRange","collapseToStart","insertBlock","insertBlockAtRange","collapseToEndOf","insertFragment","fragment","startInline","lastText","lastInline","isAppending","hasEdgeAtStartOf","hasEdgeAtEndOf","insertFragmentAtRange","newTexts","newText","takeLast","collapseToStartOf","move","insertInline","insertInlineAtRange","insertText","getInsertMarksAtRange","insertTextAtRange","splitBlock","depth","splitBlockAtRange","collapseToEnd","removeMark","removeMarkAtRange","toggleMark","activeMarks","wrapText","prefix","suffix","wrapTextAtRange","moveStart","moveEnd","isForward","SURROGATE_START","SURROGATE_END","SPACE","CHAMELEON","PUNCTUATION","isSurrogate","code","isWord","remaining","test","charAt","getCharLength","charCodeAt","getCharOffset","getCharOffsetBackward","getCharOffsetForward","getWordOffset","started","getWordOffsetBackward","o","getWordOffsetForward","getFlag","addMarkByKey","addMarksAtRange","snapshotSelection","isStartVoid","hasVoidParent","isEndVoid","isHanging","prevText","startVoid","getClosestVoid","nextText","removeNodeByKey","endVoid","removeTextByKey","startLength","endLength","getCommonAncestor","startChild","endChild","startParent","startParentIndex","endParentIndex","startChildIndex","endChildIndex","middles","lonely","getFurthestOnlyChildAncestor","moveNodeByKey","mergeNodeByKey","normalizeNodeByKey","deleteCharBackwardAtRange","String","deleteBackwardAtRange","deleteLineBackwardAtRange","startWithVoidInline","deleteBackward","deleteWordBackwardAtRange","isEmpty","isAtStartOf","prev","prevBlock","prevInline","traversed","deleteCharForwardAtRange","deleteForwardAtRange","deleteLineForwardAtRange","deleteWordForwardAtRange","nextBlock","getNextBlock","moveToStartOf","isAtEndOf","nextInline","extra","insertNodeByKey","splitDescendantsByKey","isAtStart","getBlocks","firstBlock","lastBlock","lonelyParent","lonelyChild","removeDescendant","newIndex","nextChild","nextNodes","lastIndex","inlineChild","inlineIndex","splitNodeByKey","insertTextByKey","removeMarkByKey","setBlockAtRange","getBlocksAtRange","sets","setNodeByKey","setInlineAtRange","getInlinesAtRange","height","h","splitInlineAtRange","Infinity","toggleMarkAtRange","some","equals","unwrapBlockAtRange","createProperties","wrappers","isSuperset","toOrderedSet","toList","children","b","firstMatch","lastMatch","firstText","normalizeDocument","unwrapInlineAtRange","wrapBlockAtRange","clear","firstblock","lastblock","siblings","p1","p2","indexes","ind","wrapInlineAtRange","inlineParent","wrapInlineByKey","startInner","startInnerIndex","endInner","startInlines","endInlines","operations","bx","by","ax","ay","Math","max","min","applyOperations","insertFragmentByKey","applyOperation","getMarksAtIndex","getPreviousSibling","newKey","newPath","removeAllMarksByKey","state","removals","replaceNodeByKey","newNode","setMarkByKey","target","textKey","textOffset","a","prevIndex","unwrapInlineByKey","moveToRangeOf","unwrapBlockByKey","unwrapNodeByKey","isFirst","isLast","parentParent","parentIndex","wrapBlockByKey","wrapNodeByKey","OPERATION_ATTRIBUTES","debug","Debug","Stack","History","operation","history","undos","redos","prevBatch","peek","prevOperation","shouldSkip","shouldMerge","batch","pop","isHistory","HISTORY","isEqual","CORE_SCHEMA_RULES","invalids","objects","insertBefore","insertAfter","shift","Boolean","plugins","plugin","getPluginsWith","STACK","Schema","parents","rule","violation","context","CHILD_OBJECT_INVALID","CHILD_TYPE_INVALID","CHILD_UNKNOWN","FIRST_CHILD_OBJECT_INVALID","FIRST_CHILD_TYPE_INVALID","LAST_CHILD_OBJECT_INVALID","LAST_CHILD_TYPE_INVALID","CHILD_REQUIRED","NODE_TEXT_INVALID","PARENT_OBJECT_INVALID","PARENT_TYPE_INVALID","NODE_DATA_INVALID","NODE_IS_VOID_INVALID","NODE_MARK_INVALID","t","getRule","getParentRules","ctx","fail","fn","getMarks","def","types","nextDef","defs","rewind","isSchema","rules","resolveSchema","SCHEMA","d","resolveDocumentRule","bs","resolveNodeRule","customizer","source","Value","Change","preserveData","preserveDecorations","preserveHistory","preserveSelection","preserveSchema","getPreviousBlock","getNextInline","getPreviousInline","getMarksAtRange","getFragmentAtRange","isValue","save","VALUE","Operation","json","ATTRIBUTES","toJS","isOperation","OPERATION","invertOperation","op","inverse","inversePath","inverseNewPath","pathLast","newPathLast","e","inverseNode","inverseProperties","pick","inverseMark","assertPath","inverseSelection","inverseProps","inverseValue","redo","omit","undo","invert","snapshot","k","moved","hasOwnProperty","selectAll","moveAnchorCharBackward","anchorBlock","previousText","isInVoid","isPreviousInVoid","moveAnchor","moveAnchorToEndOf","hasNode","moveAnchorCharForward","isNextInVoid","moveFocusCharBackward","focusBlock","moveFocus","moveFocusCharForward","moveFocusToStartOf","MOVE_DIRECTIONS","collapse","PREFIXES","DIRECTIONS","OBJECTS","edges","edge","getDirectionNode","directionKey","setValue","normalizeNodeAndChildren","normalizedKeys","lastSize","nextIndex","refindNode","refindPath","normalizeNode","iterations","iterate","validate","AtCurrentRange","AtRange","ByKey","OnHistory","OnSelection","OnValue","WithSchema","APPLIERS","withPath","oneIndex","twoIndex","mergeNode","newParentPath","oldParentPath","oldIndex","x","hasStartNode","hasEndNode","moveStartTo","deselect","moveEndTo","rangeOffset","removeText","updateMark","CHANGE","flags","customChange","setOperationFlag","call"],"mappings":"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"}